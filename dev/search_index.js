var documenterSearchIndex = {"docs":
[{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"using CoherentNoise","category":"page"},{"location":"getting_started/#installation","page":"Getting Started","title":"Installation","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"CoherentNoise.jl exists in the Julia's General registry. In Julia ≥ 1.0, you can add it using the package manager with:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"pkg> add CoherentNoise","category":"page"},{"location":"getting_started/#Basic-Usage","page":"Getting Started","title":"Basic Usage","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"The following is only a brief explanation of basic usage. For more advanced usage examples, please see the Tutorial section.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"To get started, let's get a feel for how to create a sampler and sample from it for one of the supported noise algorithms. Perlin noise is a well-known algorithm so let's create a 2-dimensional Perlin noise sample and sample from it:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"using CoherentNoise\nsampler = Perlin{2}()\nsample(sampler, 120.2, 42.8)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"To create a sampler we simply invoke the constructor for its type, passing in one of the supported dimensions as a type parameter. We can then sample from it using the sample function, passing in as arguments, a sampler, and multiple Real arguments corresponding to the coordinates in the sampler's noise space. In this example, we have a 2-dimensional sampler, so we passed 2 numbers; one for the coordinate along the X axis, and one for the coordinate along the Y axis.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"note: Note\nIt is strongly recommended to use floating-point numbers with a fractional component (non-zero value after the decimal point), as some algorithms (noteably Perlin noise), will return zero for integral coordinates.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"There is one potential problem with the above example though: every time we create a sampler and sample from it with the same input coordinates, it will produce a different output:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"sampler = Perlin{2}()\nsample(sampler, 120.2, 42.8)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Doesn't that conflict with the first property of coherent noise mentioned in \"What is coherent noise?\"? No, it doesn't. By not supplying any arguments to the sampler constructor, we are telling CoherentNoise to seed this sampler from your machine's hardware random number generator. All samplers have their own distinct random number generator, and it is how we can retrieve different results with the same input. We can change this behavior on a per-sampler basis, by supplying our own seed:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"sampler = Perlin{2}(seed=42)\nsample(sampler, 120.2, 42.8)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"sampler = Perlin{2}(seed=42)\nsample(sampler, 120.2, 42.8)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Now, when we run this multiple times, we will always get the same result, and this is guaranteed to be reproducible across different machines.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"note: Note\nJulia is free to change the implementation of its random number generator algorithms, even across patch versions, so this reproducibility may not hold across Julia versions. In the future, it might be worth considering to add support for CoherentNoise to use StableRNGs.jl or RandomNumbers.jl for truly portable reproducibility, but this is not a high priority.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"In summary, one creates a sampler by calling a constructor for the desired algorithm and dimensionality, and reproducibility can be controlled by supplying a seed keyword argument on a per-sampler basis.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Of particular note is that all samplers accept a seed keyword argument; even those that don't make use of any random numbers in their implementation. This is required for the composition pipeline feature described in the Tutorial.","category":"page"},{"location":"overview/#What-is-coherent-noise?","page":"Overview","title":"What is coherent noise?","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"Unlike its more random cousin, coherent noise has interesting properties that give it a smooth appearance. A coherent noise function is a function that emits a single scalar value as its output. All coherent noise functions exhibit the following three properties:","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"The same input arguments will always result in the same output.\nA small change in input will result in a small change in the output.\nA large change in input will result in a random output.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"The dimensionality of a coherent noise function is determined by how many input arguments it accepts. Since inputs to a coherent noise function could be driven from any source of data, and output values are spatially coherent in each  dimension, one could feed image coordinates into a 3-dimensional coherent noise function's first two arguments, and an incrementing time value as the third argument, in order to smoothly animate an image effect such as clouds, fire, landscapes, or anything else creativity dreams up. Similarly, one could render a 3-dimensional volume, and animate it along a 4th dimension.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Coherent noise functions are especially ubiquitous in applications where memory is scarce, and in game development where one wants to generate 2-dimensional textures or 3-dimensional objects without storing large chunks of image or geometry data on disk.","category":"page"},{"location":"overview/#History","page":"Overview","title":"History","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"CoherentNoise started out as a Common Lisp library providing a collection of noise algorithms for use in game development, but evolved over time into a more general form we thought could be useful to others outside of that domain. Additionally, the author has since migrated from Common Lisp to Julia, and here this port with even more functionality was born. The implementation borrows a lot of its ideas from C++'s libnoise and other noise libraries, but adds numerous enhancements, corrections, and additional noise algorithms.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"As mentioned, the main author, Michael Fiano, has recently moved to Julia after nearly 20 years of exclusive Common Lisp development. CoherentNoise is a realization of their first Julia library, and as such, code may not be the most idiomatic in nature. However, it was a goal to produce something as Julian as possible, and with a focus on performance and precision, than to directly port the original Common Lisp implementation. If something can be improved in this regard, please open an issue or pull request – it would be wonderful if I could stengthen my Julia knowledge by discussion or contribution by more experienced Julia developers that find value in CoherentNoise.","category":"page"},{"location":"overview/#What's-different-from-other-libraries?","page":"Overview","title":"What's different from other libraries?","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"Many more noise algorithms than libnoise supported and well-tested.\nAlgorithms are consistently implemented in 2, 3, and 4 dimensions, whereas libnoise only has 3-dimensional gradient noise.\nOmission of 1-dimensional noise algorithms, as many are difficult to implement or are not well-defined, and are not very useful in general. It was opted for a consistent interface over adding hacks to support 1-dimensional variants. This is in contrast to a lot of other libraries, excluding libnoise, which only provides 3-dimensional gradient noise.\nSome terminology corrections. For example, libnoise refers to multiple octaves of gradient noise as \"Perlin\" noise. Perlin is an implementation of gradient noise, and is not defined in terms of a fractal; infact, any noise algorithm can be \"fractalized\".\nFix quite a few fundamental mathematical errors. It was quite the task re-implementing some algorithms due to incorrect math, or the inclusion of magic numbers that differed among implementations for various reasons.\nEnsure that all samplers emit values in the [-1.0, 1.0] range; something that becomes very important when working with fractal-based noises, composition of complex noises, and in general is something just expected when working with coherent noise.\nThe Perlin noise implementation is Ken Perlin's \"Improved Noise\" algorithm, unlike his original Perlin noise algorithm found in libnoise, which is sometimes just called value or gradient noise, of which we also support, called Value.\nFractal samplers can be driven by any source sampler, not just gradient noise – even other fractal samplers.\nAdditional modifier samplers.","category":"page"},{"location":"overview/#How-is-it-used?","page":"Overview","title":"How is it used?","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"In summary, you call a constructor depending on the coherent noise algorithm and dimensionality you want to generate, in order to create a \"sampler\". A sampler can then be sampled from with the sample function, by passing to it a sampler instance, along with input coordinates for each of the sampler's dimensions.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"In addition to noise algorithm samplers, there are simple pattern samplers, and higher-order fractal and modifier samplers.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Pattern samplers create simple patterns, like checkerboards, and are useful in noise composition pipelines.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Higher-order samplers include both fractal samplers and modifier samplers.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Fractal sampler constructors accept another sampler as an input source, and produce much more interesting results by combining the results of multiple octaves of the source.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Modifier sampler constructors also accept other sampler instance as input; and modify their input coordinates or output values in interesting ways. Modifiers are the crux of CoherentNoise's composition pipeline support, and allow merging different samplers together, even other modifiers, into a composition of potentially very complex and interesting results.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Finally, there are tools available to conveniently work with 2-dimensional slices of multi-dimensional noise spaces in order to generate entire images effortlessly.","category":"page"},{"location":"overview/#Available-samplers","page":"Overview","title":"Available samplers","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"The following noise algorithms and other samplers are implemented. If you would like to see support for other sampler types, please file an issue, or submit a pull request.","category":"page"},{"location":"overview/#Noise-samplers","page":"Overview","title":"Noise samplers","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"Value (2D, 3D, 4D)\nPerlin \"Improved\" (2D, 3D, 4D)\nSimplex (2D, 3D, 4D)\nOpenSimplex (2D, 3D, 4D)\nOpenSimplex2 (2D, 3D, 4D)\nOpenSimplex2S (2D, 3D, 4D)\nCellular (2D, 3D, 4D)","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"warning: Warning\nSimplex noise ≥ 3 dimensions is patented for certain applications. It is strongly recommended to use one of the supported OpenSimplex noise algorithms in its place if you are uncertain if your use of Simplex noise is in violation of the patent.","category":"page"},{"location":"overview/#Pattern-samplers","page":"Overview","title":"Pattern samplers","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"Constant (1D)\nCheckered (2D)\nCylinders (2D)\nSpheres (3D)","category":"page"},{"location":"overview/#Fractal-samplers","page":"Overview","title":"Fractal samplers","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"FBM (fractional Brownian motion; 2D, 3D, 4D)\nBillow (2D, 3D, 4D)\nMultifractal (2D, 3D, 4D)\nHybrid (2D, 3D, 4D)\nRidged (2D, 3D, 4D)","category":"page"},{"location":"overview/#Modifier-samplers","page":"Overview","title":"Modifier samplers","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"+: binary addition of two samplers\n+: binary addition of a sampler and a scalar\n-: binary subtraction of two samplers\n-: binary subtraction of a sampler and a scalar\n-: unary subtraction of a sampler\n*: binary multiplication of two samplers\n*: binary multiplication of a sampler and a scalar\n/: binary division of two samplers\n/: binary division of a sampler and a scalar\n^: binary exponentiation of two samplers\nabs: absolute value of a sampler\ncache: cache the last output of a sampler\nclamp: restrict the range of a sampler by the bounds specified by the output of two other samplers\nclamp: restrict the range of a sampler by the bounds specified by two scalars\ncopysign: change the sign of a sampler to that of the output of another sampler\ncurve: maps the output of a sampler onto an arbitrary user-defined curve\nmax: take the maximum value of two samplers\nmin: take the minimum value of two samplers\nmix: linearly interpolate the result of two samplers by the result of a third alpha sampler\nmix: linearly interpolate the result of two samplers by a scalar\nmuladd: multiplication followed by addition of a sampler by two scalars\nrotate: rotate the noise space of a sampler around its origin by scalars denoting axis angles of rotation in radians\nscale: scale the output of a sampler by scalars for the specified axes\nscale: uniformly scale the output of a sampler along all axes\nselect: select the result of one of two samplers decided upon by the output of a third sampler\nterrace: maps the output of a sampler onto a terrace-forming curve\ntranslate: translate (move) the noise space of a sampler along the specified axes\nturbulence: randomly displace the input coordinates of a sampler before sampling from it\nwarp: domain-warps the sampler by modifying its input coordinates to be summed with the result of another supplied sampler for each coordinate","category":"page"},{"location":"gallery/#user_creations","page":"Gallery","title":"User Creations","text":"","category":"section"},{"location":"gallery/","page":"Gallery","title":"Gallery","text":"Nothing here yet. Please feel free to submit a pull request or issue with your creations to be added to this section. You can use the example markup in the Tutorial file to dynamically generate your images.","category":"page"},{"location":"reference/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"Modules = [\n  CoherentNoise.Common,\n  CoherentNoise.Patterns,\n  CoherentNoise.Noise,\n  CoherentNoise.Noise.ValueNoise,\n  CoherentNoise.Noise.PerlinNoise,\n  CoherentNoise.Noise.SimplexNoise,\n  CoherentNoise.Noise.OpenSimplexNoise,\n  CoherentNoise.Noise.OpenSimplex2Noise,\n  CoherentNoise.Noise.OpenSimplex2SNoise,\n  CoherentNoise.Noise.CellularNoise,\n  CoherentNoise.Fractals,\n  CoherentNoise.Modifiers\n]\nOrder = [:type, :function]","category":"page"},{"location":"reference/#CoherentNoise.Common.AbstractSampler","page":"API Reference","title":"CoherentNoise.Common.AbstractSampler","text":"Supertype for all N-dimensional samplers.\n\n\n\n\n\n","category":"type"},{"location":"reference/#CoherentNoise.Common.gen_image-Union{Tuple{S}, Tuple{N}} where {N, S<:AbstractSampler{N}}","page":"API Reference","title":"CoherentNoise.Common.gen_image","text":"gen_image(sampler::AbstractSampler; kwargs...)\n\nConstruct a 2-dimensional array of ColorTypes.RGB values, suitable for writing to disk as an image file.\n\nArguments\n\nsampler::AbstractSampler: Any instance of a sampler. The sampler is sampled using each pixel coordinates as the X and Y input coordinates, and random Z and W coordinates for 3 and 4-dimensional samplers.\nw::Integer=1024: The width in pixels of the image array to generate.\nh::Integer=1024: The height in pixels of the image array to generate.\nxbounds::NTuple{2,Float64}=(-1.0, 1.0): The bounds along the X axis to sample coordinates from. This remaps pixel coordinates to this range to be used for the input coordinates to sample with.\nybounds::NTuple{2,Float64}=(-1.0, 1.0): The bounds along the Y axis to sample coordinates from. This remaps pixel coordinates to this range to be used for the input coordinates to sample with.\ncolorscheme=nothing: A ColorSchemes.ColorScheme object to colorize the image with, or nothing.\n\n\n\n\n\n","category":"method"},{"location":"reference/#CoherentNoise.Common.sample","page":"API Reference","title":"CoherentNoise.Common.sample","text":"sample(sampler::AbstractSampler, x)\nsample(sampler::AbstractSampler, x, y)\nsample(sampler::AbstractSampler, x, y, z)\nsample(sampler::AbstractSampler, x, y, z, w)\n\nSample from sampler with the supplied coordinates. The number of coordinates should match the dimensionality of the sampler type.\n\n\n\n\n\n","category":"function"},{"location":"reference/#CoherentNoise.Patterns.Checkered","page":"API Reference","title":"CoherentNoise.Patterns.Checkered","text":"A 2-dimensional sampler that generates a checkerboard pattern.\n\n\n\n\n\n","category":"type"},{"location":"reference/#CoherentNoise.Patterns.Checkered-Tuple{}","page":"API Reference","title":"CoherentNoise.Patterns.Checkered","text":"Checkered(; seed=nothing)\n\nConstruct a sampler that outputs values in a checkerboard-like pattern when it is sampled from.\n\nThat is, output values will only ever be -1.0 or 1.0.\n\nArguments\n\nseed::Union{Int,Nothing}=nothing: An integer used to seed the random number generator for this sampler, or nothing. If a seed is not supplied, one will be generated automatically which will negatively affect the reproducibility of any samplers further down the pipeline.\n\n\n\n\n\n","category":"method"},{"location":"reference/#CoherentNoise.Patterns.Constant","page":"API Reference","title":"CoherentNoise.Patterns.Constant","text":"A 1-dimensional sampler that emits a constant value.\n\n\n\n\n\n","category":"type"},{"location":"reference/#CoherentNoise.Patterns.Constant-Tuple{}","page":"API Reference","title":"CoherentNoise.Patterns.Constant","text":"Constant(; seed=nothing, value=0.0)\n\nConstruct a sampler that constantly outputs value each time it is sampled from.\n\nThis is useful for debugging and applications where you need to combine a constant value.\n\nArguments\n\nseed::Union{Int,Nothing}=nothing: An integer used to seed the random number generator for this sampler, or nothing. If a seed is not supplied, one will be generated automatically which will negatively affect the reproducibility of any samplers further down the pipeline.\nvalue::Real=0.0: A constant value to emit each time this sampler is sampled from.\n\n\n\n\n\n","category":"method"},{"location":"reference/#CoherentNoise.Patterns.Cylinders","page":"API Reference","title":"CoherentNoise.Patterns.Cylinders","text":"A 2-dimensional sampler that generates a pattern of concentric cylinders.\n\n\n\n\n\n","category":"type"},{"location":"reference/#CoherentNoise.Patterns.Cylinders-Tuple{}","page":"API Reference","title":"CoherentNoise.Patterns.Cylinders","text":"Cylinders(; seed=nothing, frequency=1.0)\n\nConstruct a sampler that outputs values that form a pattern representing concentric cylinders when it is sampled from.\n\nArguments\n\nseed::Union{Int,Nothing}=nothing: An integer used to seed the random number generator for this sampler, or nothing. If a seed is not supplied, one will be generated automatically which will negatively affect the reproducibility of any samplers further down the pipeline.\nfrequency::Real=1.0: The frequency of the signal, which controls how small or large the cylinders are.\n\n\n\n\n\n","category":"method"},{"location":"reference/#CoherentNoise.Patterns.PatternSampler","page":"API Reference","title":"CoherentNoise.Patterns.PatternSampler","text":"Supertype for all N-dimensional pattern samplers.\n\n\n\n\n\n","category":"type"},{"location":"reference/#CoherentNoise.Patterns.Spheres","page":"API Reference","title":"CoherentNoise.Patterns.Spheres","text":"A 3-dimensional sampler that generates a pattern of concentric spheres.\n\n\n\n\n\n","category":"type"},{"location":"reference/#CoherentNoise.Patterns.Spheres-Tuple{}","page":"API Reference","title":"CoherentNoise.Patterns.Spheres","text":"Spheres(; seed=nothing, frequency=1.0)\n\nConstruct a sampler that outputs values that form a pattern representing concentric spheres when it is sampled from.\n\nArguments\n\nseed::Union{Int,Nothing}=nothing: An integer used to seed the random number generator for this sampler, or nothing. If a seed is not supplied, one will be generated automatically which will negatively affect the reproducibility of any samplers further down the pipeline.\nfrequency::Real=1.0: The frequency of the signal, which controls how small or large the spheres are.\n\n\n\n\n\n","category":"method"},{"location":"reference/#CoherentNoise.Noise.NoiseSampler","page":"API Reference","title":"CoherentNoise.Noise.NoiseSampler","text":"Supertype for all N-dimensional noise samplers.\n\n\n\n\n\n","category":"type"},{"location":"reference/#CoherentNoise.Noise.ValueNoise.Value","page":"API Reference","title":"CoherentNoise.Noise.ValueNoise.Value","text":"An N-dimensional sampler that generates value noise.\n\nN must be an integer in the range [2, 4].\n\n\n\n\n\n","category":"type"},{"location":"reference/#CoherentNoise.Noise.ValueNoise.Value-Union{Tuple{}, Tuple{N}} where N","page":"API Reference","title":"CoherentNoise.Noise.ValueNoise.Value","text":"Value{N}(; seed=nothing)\n\nConstruct a sampler that outputs N-dimensional value noise when it is sampler from.\n\nArguments\n\nseed::Union{Int,Nothing}=nothing: An integer used to seed the random number generator for this sampler, or nothing. If a seed is not supplied, one will be generated automatically which will negatively affect reproducibility.\n\n\n\n\n\n","category":"method"},{"location":"reference/#CoherentNoise.Noise.PerlinNoise.Perlin","page":"API Reference","title":"CoherentNoise.Noise.PerlinNoise.Perlin","text":"An N-dimensional sampler that generates Perlin \"Improved\" noise.\n\nN must be an integer in the range [2, 4].\n\n\n\n\n\n","category":"type"},{"location":"reference/#CoherentNoise.Noise.PerlinNoise.Perlin-Union{Tuple{}, Tuple{N}} where N","page":"API Reference","title":"CoherentNoise.Noise.PerlinNoise.Perlin","text":"Perlin{N}(; seed=nothing)\n\nConstruct a sampler that outputs N-dimensional Perlin \"Improved\" noise when it is sampler from.\n\nArguments\n\nseed::Union{Int,Nothing}=nothing: An integer used to seed the random number generator for this sampler, or nothing. If a seed is not supplied, one will be generated automatically which will negatively affect reproducibility.\n\n\n\n\n\n","category":"method"},{"location":"reference/#CoherentNoise.Noise.SimplexNoise.Simplex","page":"API Reference","title":"CoherentNoise.Noise.SimplexNoise.Simplex","text":"An N-dimensional sampler that generates Simplex noise.\n\nN must be an integer in the range [2, 4].\n\nNote: ≥ 3 dimensions is patent-protected for certain applications. Consider using one of the OpenSimplex implementations, instead.\n\n\n\n\n\n","category":"type"},{"location":"reference/#CoherentNoise.Noise.SimplexNoise.Simplex-Union{Tuple{}, Tuple{N}} where N","page":"API Reference","title":"CoherentNoise.Noise.SimplexNoise.Simplex","text":"Simplex{N}(; seed=nothing)\n\nConstruct a sampler that outputs N-dimensional Simplex noise when it is sampler from.\n\nArguments\n\nseed::Union{Int,Nothing}=nothing: An integer used to seed the random number generator for this sampler, or nothing. If a seed is not supplied, one will be generated automatically which will negatively affect reproducibility.\n\n\n\n\n\n","category":"method"},{"location":"reference/#CoherentNoise.Noise.OpenSimplexNoise.OpenSimplex","page":"API Reference","title":"CoherentNoise.Noise.OpenSimplexNoise.OpenSimplex","text":"An N-dimensional sampler that generates OpenSimplex (legacy) noise.\n\nN must be an integer in the range [2, 4].\n\nNote: This version of OpenSimplex is considered \"legacy\" by its original author. Consider using one of the newer algorithms, OpenSimplex2  or OpenSimplex2S.\n\n\n\n\n\n","category":"type"},{"location":"reference/#CoherentNoise.Noise.OpenSimplexNoise.OpenSimplex-Union{Tuple{}, Tuple{N}} where N","page":"API Reference","title":"CoherentNoise.Noise.OpenSimplexNoise.OpenSimplex","text":"OpenSimplex{N}(; seed=nothing)\n\nConstruct a sampler that outputs N-dimensional OpenSimplex noise when it is sampler from.\n\nArguments\n\nseed::Union{Int,Nothing}=nothing: An integer used to seed the random number generator for this sampler, or nothing. If a seed is not supplied, one will be generated automatically which will negatively affect reproducibility.\n\n\n\n\n\n","category":"method"},{"location":"reference/#CoherentNoise.Noise.OpenSimplex2Noise.ImproveX","page":"API Reference","title":"CoherentNoise.Noise.OpenSimplex2Noise.ImproveX","text":"Re-orient the noise space with the Y axis pointing down the main diagonal.\n\n\n\n\n\n","category":"type"},{"location":"reference/#CoherentNoise.Noise.OpenSimplex2Noise.ImproveXY","page":"API Reference","title":"CoherentNoise.Noise.OpenSimplex2Noise.ImproveXY","text":"Re-orient the noise space to have better visual isotropy in the XY plane.\n\n\n\n\n\n","category":"type"},{"location":"reference/#CoherentNoise.Noise.OpenSimplex2Noise.ImproveXYZ","page":"API Reference","title":"CoherentNoise.Noise.OpenSimplex2Noise.ImproveXYZ","text":"Re-orient a 4-dimensional noise space to be better suited for time-varied animations, where the W axis is time.\n\n\n\n\n\n","category":"type"},{"location":"reference/#CoherentNoise.Noise.OpenSimplex2Noise.ImproveXZ","page":"API Reference","title":"CoherentNoise.Noise.OpenSimplex2Noise.ImproveXZ","text":"Re-orient the noise space to have better visual isotropy in the XZ plane.\n\n\n\n\n\n","category":"type"},{"location":"reference/#CoherentNoise.Noise.OpenSimplex2Noise.OpenSimplex2","page":"API Reference","title":"CoherentNoise.Noise.OpenSimplex2Noise.OpenSimplex2","text":"An N-dimensional sampler that generates OpenSimplex2 noise, with an orientation of O.\n\nOpenSimplex2 is not as smooth as OpenSimplex2S, although more performant.\n\nN must be an integer in the range [2, 4].\n\nO must be an Orientation type.\n\n\n\n\n\n","category":"type"},{"location":"reference/#CoherentNoise.Noise.OpenSimplex2Noise.OpenSimplex2-Union{Tuple{}, Tuple{N}} where N","page":"API Reference","title":"CoherentNoise.Noise.OpenSimplex2Noise.OpenSimplex2","text":"OpenSimplex2{N}(; seed=nothing)\n\nConstruct a sampler that outputs N-dimensional OpenSimplex2 noise when it is sampler from.\n\nThe noise space will be re-oriented using Standard orientation.\n\nArguments\n\nseed::Union{Int,Nothing}=nothing: An integer used to seed the random number generator for this sampler, or nothing. If a seed is not supplied, one will be generated automatically which will negatively affect reproducibility.\n\n\n\n\n\n","category":"method"},{"location":"reference/#CoherentNoise.Noise.OpenSimplex2Noise.OpenSimplex2-Union{Tuple{}, Tuple{O}, Tuple{N}} where {N, O}","page":"API Reference","title":"CoherentNoise.Noise.OpenSimplex2Noise.OpenSimplex2","text":"OpenSimplex2{N,O}(; seed=nothing)\n\nConstruct a sampler that outputs N-dimensional OpenSimplex2 noise when it is sampler from.\n\nThe noise space is re-oriented according by the supplied Orientation type O.\n\nArguments\n\nseed::Union{Int,Nothing}=nothing: An integer used to seed the random number generator for this sampler, or nothing. If a seed is not supplied, one will be generated automatically which will negatively affect reproducibility.\n\n\n\n\n\n","category":"method"},{"location":"reference/#CoherentNoise.Noise.OpenSimplex2Noise.Orientation","page":"API Reference","title":"CoherentNoise.Noise.OpenSimplex2Noise.Orientation","text":"Supertype of all orientations that can be applied to the OpenSimplex2 or OpenSimplex2S sampler types to re-orient the noise space.\n\n\n\n\n\n","category":"type"},{"location":"reference/#CoherentNoise.Noise.OpenSimplex2Noise.Standard","page":"API Reference","title":"CoherentNoise.Noise.OpenSimplex2Noise.Standard","text":"The standard orientation for OpenSimplex2 and OpenSimplex2S.\n\n\n\n\n\n","category":"type"},{"location":"reference/#CoherentNoise.Noise.OpenSimplex2SNoise.OpenSimplex2S","page":"API Reference","title":"CoherentNoise.Noise.OpenSimplex2SNoise.OpenSimplex2S","text":"An N-dimensional sampler that generates OpenSimplex2S noise, with an orientation of O.\n\nOpenSimplex2S is smoother than OpenSimplex2, at the expense of being less performant.\n\nN must be an integer in the range [2, 4].\n\nO must be an Orientation type.\n\n\n\n\n\n","category":"type"},{"location":"reference/#CoherentNoise.Noise.OpenSimplex2SNoise.OpenSimplex2S-Union{Tuple{}, Tuple{N}} where N","page":"API Reference","title":"CoherentNoise.Noise.OpenSimplex2SNoise.OpenSimplex2S","text":"OpenSimplex2S{N}(; seed=nothing)\n\nConstruct a sampler that outputs N-dimensional OpenSimplex2S noise when it is sampler from.\n\nThe noise space will be re-oriented using Standard orientation.\n\nArguments\n\nseed::Union{Int,Nothing}=nothing: An integer used to seed the random number generator for this sampler, or nothing. If a seed is not supplied, one will be generated automatically which will negatively affect reproducibility.\n\n\n\n\n\n","category":"method"},{"location":"reference/#CoherentNoise.Noise.OpenSimplex2SNoise.OpenSimplex2S-Union{Tuple{}, Tuple{O}, Tuple{N}} where {N, O}","page":"API Reference","title":"CoherentNoise.Noise.OpenSimplex2SNoise.OpenSimplex2S","text":"OpenSimplex2S{N,O}(; seed=nothing)\n\nConstruct a sampler that outputs N-dimensional OpenSimplex2S noise when it is sampler from.\n\nThe noise space is re-oriented according by the supplied Orientation type O.\n\nArguments\n\nseed::Union{Int,Nothing}=nothing: An integer used to seed the random number generator for this sampler, or nothing. If a seed is not supplied, one will be generated automatically which will negatively affect reproducibility.\n\n\n\n\n\n","category":"method"},{"location":"reference/#CoherentNoise.Noise.CellularNoise.CellFunction","page":"API Reference","title":"CoherentNoise.Noise.CellularNoise.CellFunction","text":"Supertype of all cellular noise cell functions.\n\n\n\n\n\n","category":"type"},{"location":"reference/#CoherentNoise.Noise.CellularNoise.Cellular","page":"API Reference","title":"CoherentNoise.Noise.CellularNoise.Cellular","text":"An N-dimensional sampler that generates cellular (Voronoi/Worley) noise.\n\nN must be an integer in the range [2, 4]. M must be a DistanceMetric type. F must be a CellFunction type.\n\n\n\n\n\n","category":"type"},{"location":"reference/#CoherentNoise.Noise.CellularNoise.Cellular-Union{Tuple{}, Tuple{N}} where N","page":"API Reference","title":"CoherentNoise.Noise.CellularNoise.Cellular","text":"Cellular{N}(; seed=nothing)\nCellular{N,M}(; seed=nothing)\nCellular{N,M,F}(; seed=nothing)\n\nConstruct a sampler that outputs N-dimensional cellular noise when it is sampler from.\n\nM if supplied, must be a DistanceMetric type, which denotes the method to use for determining adjacent cells.\n\nF if supplied, must be a CellFunction type, which denotes the \"cell function\" used in the cell distance calculation.\n\nArguments\n\nseed::Union{Int,Nothing}=nothing: An integer used to seed the random number generator for this sampler, or nothing. If a seed is not supplied, one will be generated automatically which will negatively affect reproducibility.\njitter::Real=1.0: A Real number between 0.0 and 1.0, with values closer to one randomly distributing cells away from their grid alignment.\n\n\n\n\n\n","category":"method"},{"location":"reference/#CoherentNoise.Noise.CellularNoise.Chebyshev","page":"API Reference","title":"CoherentNoise.Noise.CellularNoise.Chebyshev","text":"Use the Chebyshev distance metric for determining the distance between two cells.\n\n\n\n\n\n","category":"type"},{"location":"reference/#CoherentNoise.Noise.CellularNoise.DistanceMetric","page":"API Reference","title":"CoherentNoise.Noise.CellularNoise.DistanceMetric","text":"Supertype of all cellular noise distance metrics.\n\n\n\n\n\n","category":"type"},{"location":"reference/#CoherentNoise.Noise.CellularNoise.Euclidean","page":"API Reference","title":"CoherentNoise.Noise.CellularNoise.Euclidean","text":"Use the Euclidean distance metric for determining the distance between two cells.\n\n\n\n\n\n","category":"type"},{"location":"reference/#CoherentNoise.Noise.CellularNoise.Euclidean²","page":"API Reference","title":"CoherentNoise.Noise.CellularNoise.Euclidean²","text":"Use the squared Euclidean distance metric for determining the distance between two cells.\n\n\n\n\n\n","category":"type"},{"location":"reference/#CoherentNoise.Noise.CellularNoise.Manhattan","page":"API Reference","title":"CoherentNoise.Noise.CellularNoise.Manhattan","text":"Use the Manhattan distance metric for determining the distance between two cells.\n\n\n\n\n\n","category":"type"},{"location":"reference/#CoherentNoise.Noise.CellularNoise.Minkowski4","page":"API Reference","title":"CoherentNoise.Noise.CellularNoise.Minkowski4","text":"Use the Minkowski4 (p=4) distance metric for determining the distance between two cells.\n\n\n\n\n\n","category":"type"},{"location":"reference/#CoherentNoise.Fractals.Billow","page":"API Reference","title":"CoherentNoise.Fractals.Billow","text":"An N-dimensional sampler that generates a billowy fractal.\n\nN must be an integer in the range [2, 4].\n\nS may be an instance of any AbstractSampler, or an un-parameterized concrete type of one.\n\nO denotes the number of octaves to apply for this fractal.\n\n\n\n\n\n","category":"type"},{"location":"reference/#CoherentNoise.Fractals.Billow-Union{Tuple{}, Tuple{N}} where N","page":"API Reference","title":"CoherentNoise.Fractals.Billow","text":"Billow{N}(; kwargs...)\n\nConstruct a sampler that outputs an N-dimensional billowy fractal noise when it is sampler from.\n\nArguments\n\nseed::Union{Int,Nothing}=nothing: An integer used to seed the random number generator for this sampler, or nothing. If a seed is not supplied, one will be generated automatically which will negatively affect reproducibility.\nsource::Union{Type{<:AbstractSampler},AbstractSampler}=OpenSimplex2S: A sampler type or sampler instance to use as the source of the fractal. If this is an instance, its dimensionality must match N.\noctaves=4: An integer between 1 and 32, denoting the number of octaves to apply.\nfrequency=1.0: The frequency of the first octave's signal.\nlacunarity=2.0: A multiplier that determines how quickly the frequency increases for successive octaves.\npersistence=0.5: A multiplier that determines how quickly the amplitude diminishes for successive octaves.\nargs...: Additional arguments to pass to the source if it is a type instead of an instance.\n\n\n\n\n\n","category":"method"},{"location":"reference/#CoherentNoise.Fractals.FBM","page":"API Reference","title":"CoherentNoise.Fractals.FBM","text":"An N-dimensional sampler that generates a fractional Brownian motion fractal.\n\nN must be an integer in the range [2, 4].\n\nS may be an instance of any AbstractSampler, or an un-parameterized concrete type of one.\n\nO denotes the number of octaves to apply for this fractal.\n\n\n\n\n\n","category":"type"},{"location":"reference/#CoherentNoise.Fractals.FBM-Union{Tuple{}, Tuple{N}} where N","page":"API Reference","title":"CoherentNoise.Fractals.FBM","text":"FBM{N}(; kwargs...)\n\nConstruct a sampler that outputs an N-dimensional fractional Brownian motion fractal noise when it is sampler from.\n\nArguments\n\nseed::Union{Int,Nothing}=nothing: An integer used to seed the random number generator for this sampler, or nothing. If a seed is not supplied, one will be generated automatically which will negatively affect reproducibility.\nsource::Union{Type{<:AbstractSampler},AbstractSampler}=OpenSimplex2: A sampler type or sampler instance to use as the source of the fractal. If this is an instance, its dimensionality must match N.\noctaves=4: An integer between 1 and 32, denoting the number of octaves to apply.\nfrequency=1.0: The frequency of the first octave's signal.\nlacunarity=2.0: A multiplier that determines how quickly the frequency increases for successive octaves.\npersistence=0.5: A multiplier that determines how quickly the amplitude diminishes for successive octaves.\nargs...: Additional arguments to pass to the source if it is a type instead of an instance.\n\n\n\n\n\n","category":"method"},{"location":"reference/#CoherentNoise.Fractals.FractalSampler","page":"API Reference","title":"CoherentNoise.Fractals.FractalSampler","text":"Supertype for all N-dimensional fractal samplers.\n\n\n\n\n\n","category":"type"},{"location":"reference/#CoherentNoise.Fractals.Hybrid","page":"API Reference","title":"CoherentNoise.Fractals.Hybrid","text":"An N-dimensional sampler that generates a hybrid multifractal.\n\nN must be an integer in the range [2, 4].\n\nS may be an instance of any AbstractSampler, or an un-parameterized concrete type of one.\n\nO denotes the number of octaves to apply for this fractal.\n\n\n\n\n\n","category":"type"},{"location":"reference/#CoherentNoise.Fractals.Hybrid-Union{Tuple{}, Tuple{N}} where N","page":"API Reference","title":"CoherentNoise.Fractals.Hybrid","text":"Hybrid{N}(; kwargs...)\n\nConstruct a sampler that outputs an N-dimensional hybrid multifractal noise when it is sampler from.\n\nArguments\n\nseed::Union{Int,Nothing}=nothing: An integer used to seed the random number generator for this sampler, or nothing. If a seed is not supplied, one will be generated automatically which will negatively affect reproducibility.\nsource::Union{Type{<:AbstractSampler},AbstractSampler}=OpenSimplex2S: A sampler type or sampler instance to use as the source of the fractal. If this is an instance, its dimensionality must match N.\noctaves=4: An integer between 1 and 32, denoting the number of octaves to apply.\nfrequency=1.0: The frequency of the first octave's signal.\nlacunarity=2.0: A multiplier that determines how quickly the frequency increases for successive octaves.\npersistence=0.25: A multiplier that determines how quickly the amplitude diminishes for successive octaves.\nargs...: Additional arguments to pass to the source if it is a type instead of an instance.\n\n\n\n\n\n","category":"method"},{"location":"reference/#CoherentNoise.Fractals.Multifractal","page":"API Reference","title":"CoherentNoise.Fractals.Multifractal","text":"An N-dimensional sampler that generates a multifractal.\n\nN must be an integer in the range [2, 4].\n\nS may be an instance of any AbstractSampler, or an un-parameterized concrete type of one.\n\nO denotes the number of octaves to apply for this fractal.\n\n\n\n\n\n","category":"type"},{"location":"reference/#CoherentNoise.Fractals.Multifractal-Union{Tuple{}, Tuple{N}} where N","page":"API Reference","title":"CoherentNoise.Fractals.Multifractal","text":"Multifractal{N}(; kwargs...)\n\nConstruct a sampler that outputs an N-dimensional multifractal noise when it is sampler from.\n\nArguments\n\nseed::Union{Int,Nothing}=nothing: An integer used to seed the random number generator for this sampler, or nothing. If a seed is not supplied, one will be generated automatically which will negatively affect reproducibility.\nsource::Union{Type{<:AbstractSampler},AbstractSampler}=OpenSimplex2S: A sampler type or sampler instance to use as the source of the fractal. If this is an instance, its dimensionality must match N.\noctaves=4: An integer between 1 and 32, denoting the number of octaves to apply.\nfrequency=1.0: The frequency of the first octave's signal.\nlacunarity=2.0: A multiplier that determines how quickly the frequency increases for successive octaves.\npersistence=0.5: A multiplier that determines how quickly the amplitude diminishes for successive octaves.\nargs...: Additional arguments to pass to the source if it is a type instead of an instance.\n\n\n\n\n\n","category":"method"},{"location":"reference/#CoherentNoise.Fractals.Ridged","page":"API Reference","title":"CoherentNoise.Fractals.Ridged","text":"An N-dimensional sampler that generates a ridged multifractal.\n\nN must be an integer in the range [2, 4].\n\nS may be an instance of any AbstractSampler, or an un-parameterized concrete type of one.\n\nO denotes the number of octaves to apply for this fractal.\n\n\n\n\n\n","category":"type"},{"location":"reference/#CoherentNoise.Fractals.Ridged-Union{Tuple{}, Tuple{N}} where N","page":"API Reference","title":"CoherentNoise.Fractals.Ridged","text":"Ridged{N}(; kwargs...)\n\nConstruct a sampler that outputs an N-dimensional ridged multifractal noise when it is sampler from.\n\nArguments\n\nseed::Union{Int,Nothing}=nothing: An integer used to seed the random number generator for this sampler, or nothing. If a seed is not supplied, one will be generated automatically which will negatively affect reproducibility.\nsource::Union{Type{<:AbstractSampler},AbstractSampler}=OpenSimplex2S: A sampler type or sampler instance to use as the source of the fractal. If this is an instance, its dimensionality must match N.\noctaves=4: An integer between 1 and 32, denoting the number of octaves to apply.\nfrequency=1.0: The frequency of the first octave's signal.\nlacunarity=2.0: A multiplier that determines how quickly the frequency increases for successive octaves.\npersistence=1.0: A multiplier that determines how quickly the amplitude diminishes for successive octaves.\nattenuation=2.0: The attenuation to apply to the weight of each octave.\nargs...: Additional arguments to pass to the source if it is a type instead of an instance.\n\n\n\n\n\n","category":"method"},{"location":"reference/#CoherentNoise.Modifiers.ModifierSampler","page":"API Reference","title":"CoherentNoise.Modifiers.ModifierSampler","text":"Supertype for all N-dimensional modifier samplers.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Base.:*-Union{Tuple{S2}, Tuple{S1}, Tuple{N2}, Tuple{N1}, Tuple{S1, S2}} where {N1, N2, S1<:AbstractSampler{N1}, S2<:AbstractSampler{N2}}","page":"API Reference","title":"Base.:*","text":"*(x::AbstractSampler, y::AbstractSampler)\n\nConstruct a modifier sampler that outputs the product of the outputs samplers x and y.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.:*-Union{Tuple{S}, Tuple{N}, Tuple{S, Real}} where {N, S<:AbstractSampler{N}}","page":"API Reference","title":"Base.:*","text":"*(x::AbstractSampler, y::Real)\n\nConstruct a modifier sampler that outputs the product of the output of sampler x by the scalar y.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.:+-Union{Tuple{S2}, Tuple{S1}, Tuple{N2}, Tuple{N1}, Tuple{S1, S2}} where {N1, N2, S1<:AbstractSampler{N1}, S2<:AbstractSampler{N2}}","page":"API Reference","title":"Base.:+","text":"+(x::AbstractSampler, y::AbstractSampler)\n\nConstruct a modifier sampler that outputs the sum of the outputs of samplers x and y.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.:+-Union{Tuple{S}, Tuple{N}, Tuple{S, Real}} where {N, S<:AbstractSampler{N}}","page":"API Reference","title":"Base.:+","text":"+(x::AbstractSampler, y::Real)\n\nConstruct a modifier sampler that outputs the sum of the output of sampler x and the scalar y.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.:--Union{Tuple{S2}, Tuple{S1}, Tuple{N2}, Tuple{N1}, Tuple{S1, S2}} where {N1, N2, S1<:AbstractSampler{N1}, S2<:AbstractSampler{N2}}","page":"API Reference","title":"Base.:-","text":"-(x::AbstractSampler, y::AbstractSampler)\n\nConstruct a modifier sampler that outputs the difference of the outputs of samplers x and y.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.:--Union{Tuple{S}, Tuple{N}, Tuple{S, Real}} where {N, S<:AbstractSampler{N}}","page":"API Reference","title":"Base.:-","text":"-(x::AbstractSampler, y::Real)\n\nConstruct a modifier sampler that outputs the difference of the output of sampler x and the scalar y.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.:--Union{Tuple{S}, Tuple{N}} where {N, S<:AbstractSampler{N}}","page":"API Reference","title":"Base.:-","text":"-(x::AbstractSampler)\n\nConstruct a modifier sampler that outputs the negated output of sampler x.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.:/-Union{Tuple{S2}, Tuple{S1}, Tuple{N2}, Tuple{N1}, Tuple{S1, S2}} where {N1, N2, S1<:AbstractSampler{N1}, S2<:AbstractSampler{N2}}","page":"API Reference","title":"Base.:/","text":"/(x::AbstractSampler, y::AbstractSampler)\n\nConstruct a modifier sampler that performs division of the output of sampler x by the output of sampler y.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.:/-Union{Tuple{S}, Tuple{N}, Tuple{S, Real}} where {N, S<:AbstractSampler{N}}","page":"API Reference","title":"Base.:/","text":"/(x::AbstractSampler, y::Real)\n\nConstruct a modifier sampler that performs division of the output of sampler x by the scalar y.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.:^-Union{Tuple{S}, Tuple{N}, Tuple{S, Real}} where {N, S<:AbstractSampler{N}}","page":"API Reference","title":"Base.:^","text":"^(x::AbstractSampler, y::Real)\n\nConstruct a modifier sampler that raises the output of sampler x to the power of the scalar y.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.Math.clamp-Union{Tuple{H}, Tuple{L}, Tuple{S}, Tuple{N2}, Tuple{N1}, Tuple{N}, Tuple{S, L, H}} where {N, N1, N2, S<:AbstractSampler{N}, L<:AbstractSampler{N1}, H<:AbstractSampler{N2}}","page":"API Reference","title":"Base.Math.clamp","text":"clamp(x::AbstractSampler, lo::AbstractSampler, hi::AbstractSampler)\n\nConstruct a modifier sampler that clamps the output of sampler x to be within the range of of output values from samplers lo and hi.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.Math.clamp-Union{Tuple{S}, Tuple{N}, Tuple{S, Real}, Tuple{S, Real, Real}} where {N, S<:AbstractSampler{N}}","page":"API Reference","title":"Base.Math.clamp","text":"clamp(x::AbstractSampler, lo::Real=-1.0, hi::Real=1.0)\n\nConstruct a modifier sampler that clamps the output of sampler x to be within the range of of the scalars lo and hi.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.abs-Union{Tuple{S}, Tuple{N}} where {N, S<:AbstractSampler{N}}","page":"API Reference","title":"Base.abs","text":"abs(x::AbstractSampler)\n\nConstruct a modifier sampler that outputs the absolute value of its source when it is sampled from.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.copysign-Union{Tuple{S2}, Tuple{S1}, Tuple{N2}, Tuple{N1}, Tuple{S1, S2}} where {N1, N2, S1<:AbstractSampler{N1}, S2<:AbstractSampler{N2}}","page":"API Reference","title":"Base.copysign","text":"copysign(x::AbstractSampler, y::AbstractSampler)\n\nConstruct a modifier sampler that outputs the value of sampling from x with the sign copied from the value of sampling from y.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.max-Union{Tuple{S2}, Tuple{S1}, Tuple{N2}, Tuple{N1}, Tuple{S1, S2}} where {N1, N2, S1<:AbstractSampler{N1}, S2<:AbstractSampler{N2}}","page":"API Reference","title":"Base.max","text":"max(x::AbstractSampler, y::AbstractSampler)\n\nConstruct a modifier sampler that outputs the maximum value of the outputs of sampling from samplers x and y.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.min-Union{Tuple{S2}, Tuple{S1}, Tuple{N2}, Tuple{N1}, Tuple{S1, S2}} where {N1, N2, S1<:AbstractSampler{N1}, S2<:AbstractSampler{N2}}","page":"API Reference","title":"Base.min","text":"min(x::AbstractSampler, y::AbstractSampler)\n\nConstruct a modifier sampler that outputs the minimum value of the outputs of sampling from samplers x and y.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.muladd-Union{Tuple{S}, Tuple{N}, Tuple{S, Real}, Tuple{S, Real, Real}} where {N, S<:AbstractSampler{N}}","page":"API Reference","title":"Base.muladd","text":"muladd(x::AbstractSampler, strength::Real=1.0, bias::Real=0.0)\n\nConstruct a modifier sampler that performs multiplies the output of sampler x by the scalar strength, followed by adding the scalar bias. sampler y.\n\n\n\n\n\n","category":"method"},{"location":"reference/#CoherentNoise.Modifiers.cache-Union{Tuple{S}, Tuple{N}} where {N, S<:AbstractSampler{N}}","page":"API Reference","title":"CoherentNoise.Modifiers.cache","text":"cache(x::AbstractSampler)\n\nConstruct a modifier sampler that caches the set of the input coordinates and their corresponding output value of its source sampler. If the input coordinates differs from the previously cached output, the cache is invalidated and the new output is cached.\n\nCaching is useful if a sampler is used as a source for multiple modifiers. Without caching, the duplicated input sources would redundantly compute the same outputs, which would be expensive, especially if long pipelines share a long subgraph.\n\n\n\n\n\n","category":"method"},{"location":"reference/#CoherentNoise.Modifiers.curve-Union{Tuple{S}, Tuple{N}, Tuple{S, Vector{Pair{Float64, Float64}}}} where {N, S<:AbstractSampler{N}}","page":"API Reference","title":"CoherentNoise.Modifiers.curve","text":"curve(x::AbstractSampler, points::Vector{Pair{Float64,Float64}})\n\nConstruct a modifier sampler that outputs the result of sampling from x after remapping its output to an arbitrary curve.\n\nThe curve is defined by a Vector of Pairs given by points. Each pair of points represents an input and output number. The curve is a cubic spline, and so points must contain a list of four point pairs at a minimum. Additionally, no two point pairs can contain the same input point value.\n\nWhen sampling from sampler x, the output is evaluated using the curve data, and maps it to a new output value.\n\n\n\n\n\n","category":"method"},{"location":"reference/#CoherentNoise.Modifiers.mix-Union{Tuple{C}, Tuple{S2}, Tuple{S1}, Tuple{N3}, Tuple{N2}, Tuple{N1}, Tuple{S1, S2, C}} where {N1, N2, N3, S1<:AbstractSampler{N1}, S2<:AbstractSampler{N2}, C<:AbstractSampler{N3}}","page":"API Reference","title":"CoherentNoise.Modifiers.mix","text":"mix(x::AbstractSampler, y::AbstractSampler, t::AbstractSampler)\n\nConstruct a modifier sampler that outputs the result of linearly interpolating the output of samplers x and y by the output of sampler t.\n\n\n\n\n\n","category":"method"},{"location":"reference/#CoherentNoise.Modifiers.mix-Union{Tuple{S2}, Tuple{S1}, Tuple{N2}, Tuple{N1}, Tuple{S1, S2, Real}} where {N1, N2, S1<:AbstractSampler{N1}, S2<:AbstractSampler{N2}}","page":"API Reference","title":"CoherentNoise.Modifiers.mix","text":"mix(x::AbstractSampler, y::AbstractSampler, t::Scalar)\n\nConstruct a modifier sampler that outputs the result of linearly interpolating the output of samplers x and y by the scalar t.\n\n\n\n\n\n","category":"method"},{"location":"reference/#CoherentNoise.Modifiers.rotate-Union{Tuple{S}, Tuple{N}} where {N, S<:AbstractSampler{N}}","page":"API Reference","title":"CoherentNoise.Modifiers.rotate","text":"rotate(source::AbstractSampler; x::Real=0.0, y::Real=0.0, z::Real=0.0)\n\nConstruct a modifier sampler that rotates the input coordinates of sampler source around the origin before sampling from it.\n\nThe coordinate system is assumed to be left-handed.\n\nThe angle of rotation is specified in radians for the corresponding axis given by x, y, and z.\n\n\n\n\n\n","category":"method"},{"location":"reference/#CoherentNoise.Modifiers.scale-Union{Tuple{S}, Tuple{N}, Tuple{S, Real}} where {N, S<:AbstractSampler{N}}","page":"API Reference","title":"CoherentNoise.Modifiers.scale","text":"scale(source::AbstractSampler, scale::Real=1.0)\n\nConstruct a modifier sampler that uniformly scales the input coordinates of sampler source by the scalar scale before sampling from it.\n\n\n\n\n\n","category":"method"},{"location":"reference/#CoherentNoise.Modifiers.scale-Union{Tuple{S}, Tuple{N}} where {N, S<:AbstractSampler{N}}","page":"API Reference","title":"CoherentNoise.Modifiers.scale","text":"scale(source::AbstractSampler; x::Real=1.0, y::Real=1.0, z::Real=1.0, w::Real=1.0)\n\nConstruct a modifier sampler that scales the input coordinates of sampler source before sampling from it.\n\nEach axis can be scaled independently with x, y, z, or w.\n\n\n\n\n\n","category":"method"},{"location":"reference/#CoherentNoise.Modifiers.select-Union{Tuple{C}, Tuple{S2}, Tuple{S1}, Tuple{N3}, Tuple{N2}, Tuple{N1}, Tuple{S1, S2, C}} where {N1, N2, N3, S1<:AbstractSampler{N1}, S2<:AbstractSampler{N2}, C<:AbstractSampler{N3}}","page":"API Reference","title":"CoherentNoise.Modifiers.select","text":"select(x::AbstractSampler, y::AbstractSampler; kwargs...)\n\nConstruct a modifier sampler that outputs either the out of sampler x or y, depending on the output of sampler z.\n\nIf the output of sampler z is within the range denoted by min and max, the output of sampler y is chosen. If the output of sampler z is outside of this range, the output of sampler x is chosen.\n\nArguments\n\nmin::Real=-1.0: A real number between -1.0 and 1.0 defining the lower bound of the selection range.\nmax::Real=1.0: A real number between -1.0 and 1.0 defining the upper bound of the selection range.\nfalloff::Real=1.0: A real number between 0.0 and 1.0 specifying the smoothness of the transition.\n\n\n\n\n\n","category":"method"},{"location":"reference/#CoherentNoise.Modifiers.terrace-Union{Tuple{S}, Tuple{N}, Tuple{S, Vector{Float64}}} where {N, S<:AbstractSampler{N}}","page":"API Reference","title":"CoherentNoise.Modifiers.terrace","text":"terrace(x::AbstractSampler, points::Vector{Pair{Float64,Float64}}; invert::Bool=false)\n\nConstruct a modifier sampler that outputs the result of sampling from x after remapping its output to a terrace-forming curve.\n\nThe curve is defined by a Vector of Float64s given by points. Each point represents an input and output number.\n\nWhen sampling from sampler x, the output is evaluated using the curve data, and maps it to a new output value.\n\nArguments\n\ninvert::Bool=false: Specify whether the curve is inverted between control points.\n\n\n\n\n\n","category":"method"},{"location":"reference/#CoherentNoise.Modifiers.translate-Union{Tuple{S}, Tuple{N}} where {N, S<:AbstractSampler{N}}","page":"API Reference","title":"CoherentNoise.Modifiers.translate","text":"translate(source::AbstractSampler; x::Real=0.0, y::Real=0.0, z::Real=0.0, w::Real=0.0)\n\nConstruct a modifier sampler that translates the input coordinates of sampler source along a specified vector, with a direction and magnitude given by the coordinates x, y, z, and w.\n\n\n\n\n\n","category":"method"},{"location":"reference/#CoherentNoise.Modifiers.turbulence-Union{Tuple{S2}, Tuple{S1}, Tuple{N1}, Tuple{N}, Tuple{S1, S2}} where {N, N1, S1<:AbstractSampler{N}, S2<:AbstractSampler{N1}}","page":"API Reference","title":"CoherentNoise.Modifiers.turbulence","text":"turbulence(s1::AbstractSampler; s2::AbstractSampler; kwargs...)\n\nConstruct a modifier sampler that displaces the input coordinates of sampler s1 by the output of sampler s2 with a fractional Brownian motion fractal applied to it.\n\nSampler s2's input coordinates are randomly generated using the seed of sampler s1.\n\nArguments\n\nfrequency::Real=1.0: The frequency of the fractal signal to apply to sampler s2.\nroughness::Real=3: The number of octaves of the fractal to apply to sampler s2.\npower::Real=1.0: A scaling factor that is applied to the displaced result before sampling from sampler s1.\n\n\n\n\n\n","category":"method"},{"location":"reference/#CoherentNoise.Modifiers.warp-Union{Tuple{SW}, Tuple{SZ}, Tuple{SY}, Tuple{SX}, Tuple{S}, Tuple{N4}, Tuple{N3}, Tuple{N2}, Tuple{N1}, Tuple{N}} where {N, N1, N2, N3, N4, S<:AbstractSampler{N}, SX<:AbstractSampler{N1}, SY<:AbstractSampler{N2}, SZ<:AbstractSampler{N3}, SW<:AbstractSampler{N4}}","page":"API Reference","title":"CoherentNoise.Modifiers.warp","text":"warp(source::AbstractSampler; kwargs...)\n\nConstruct a modifier sampler that performs domain warping of the sampler source before sampling from it.\n\nDomain warping feeds the output of other samplers to the input of a sampler. For this modifier, each input coordinate can specify a different sampler to warp with.\n\nIf a sampler is not supplied for x, y, z, or w, a sampler that outputs a constant zero will be used instead.\n\nArguments\n\nx::AbstractSampler=Constant(): A sampler to warp the X axis by.\ny::AbstractSampler=Constant(): A sampler to warp the Y axis by.\nz::AbstractSampler=Constant(): A sampler to warp the Z axis by.\nw::AbstractSampler=Constant(): A sampler to warp the W axis by.\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = CoherentNoise","category":"page"},{"location":"#CoherentNoise","page":"Home","title":"CoherentNoise","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CoherentNoise is a comprehensive suite of coherent noise algorithms and composable tools for manipulating them to create interesting procedurally-generated imagery and other creative applications.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using CoherentNoise, ImageIO, FileIO, ColorSchemes, Chain\nfunction generate(file, sampler; xbounds=(-1.0, 1.0), ybounds=(-1.0, 1.0), colorscheme=nothing)\n    img = gen_image(\n        sampler, w=320, h=320, xbounds=xbounds, ybounds=ybounds, colorscheme=colorscheme)\n    save(joinpath(@__DIR__, \"assets/tutorial/$(file).png\"), img);\nend","category":"page"},{"location":"tutorial/#first_steps","page":"Tutorial","title":"First steps","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Before following along with this tutorial, it is a good idea to get familiar with how to work with samplers. See Getting Started.","category":"page"},{"location":"tutorial/#Visualizing-results","page":"Tutorial","title":"Visualizing results","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"CoherentNoise provides basic support for generating 2-dimensional slices of noise data, which can be conveniently written to disk as an image file, or rendered with tools such as ImageView.jl.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To generate an image that samples from a sampler for each pixel, it is as simple as the following, with sampler being any instance of the supported sampler types:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"sampler = OpenSimplex{2}(seed=1)\ngen_image(sampler)\ngenerate(\"tutorial01\", sampler) # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This produces an array of RGB values using ColorTypes.jl. You can then, write it out as an image file with something like:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using FileIO\nimg = gen_image(sampler)\nsave(img, \"/tmp/noise.png\")","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Which, for this example, should produce something similar to the following image:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: )","category":"page"},{"location":"tutorial/#Modifiers","page":"Tutorial","title":"Modifiers","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Modifiers are the backbone of producing interesting noise results. Using a modifier, we can alter the input coordinates before sampling, or the output value after sampling. Modifiers are just samplers, so they have no effect until sample is called on them. We can therefor compose long pipelines of noises generators, and finally evaluate the graph, as the end result is always just an ordinary sampler.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"For example, taking our previous example from Visualizing results, we can start modifying it with a simple modifier, unary subtraction (negation) of the output values.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"sampler = -OpenSimplex{2}(seed=1)\ngen_image(sampler)\ngenerate(\"tutorial02\", sampler) # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: )","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Notice the - operator in front of the sampler constructor; that was the only change. This modifier simply negates the output values.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We can get more advanced, by modifying the output values according to the outputs of other samplers. One such modifier is one created by the mix() function. This function accepts 3 samplers as input, and linearly interpolates between the outputs of the first two samplers, using the third sampler's output as a blending factor.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Let's mix our original sampler together with another new sampler, with interpolation controlled by yet another new sampler. But first, let's see what each of these looks like individually:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"sampler1 = OpenSimplex{2}(seed=1)\nsampler2 = OpenSimplex{2}(seed=2)\nsampler3 = Perlin{3}(seed=1)\ngen_image(sampler1)\ngen_image(sampler2)\ngen_image(sampler3)\ngenerate(\"tutorial03\", sampler1) # hide\ngenerate(\"tutorial04\", sampler2) # hide\ngenerate(\"tutorial05\", sampler3) # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"sampler1 sampler2 sampler3\n(Image: ) (Image: ) (Image: )","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Interpolating these with mix is done as follows:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"sampler1 = OpenSimplex{2}(seed=1)\nsampler2 = OpenSimplex{2}(seed=2)\nsampler3 = Perlin{2}(seed=1)\nmixed = mix(sampler1, sampler2, sampler3)\ngen_image(mixed)\ngenerate(\"tutorial06\", mixed) # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: )","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"It turns out, this doesn't look very interesting. This is mostly due to the fact that we are zoomed in very close to the generated noise. By default, gen_image() samples from coordinate [-1.0, 1.0] on both the X and Y axes. This can be tuned with the xbounds and ybounds parameters, but rather than doing that, let's use the scale modifier instead.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The scale modifier modifies the input coordinates of a source sampler before it is sampled from. So far we have only seen an output modifying sampler, but one can also modify input coordinates with other modifiers. Here is how we can scale down our previous example. Throughout this tutorial, the full source will be included with each example, to make it easier to copy and paste to your REPL to try things out on your own.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"sampler1 = OpenSimplex{2}(seed=1)\nsampler2 = OpenSimplex{2}(seed=2)\nsampler3 = Perlin{2}(seed=1)\nmixed = mix(sampler1, sampler2, sampler3)\nscaled = scale(mixed, 0.25)\ngen_image(scaled)\ngenerate(\"tutorial07\", scaled) # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: )","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We decreased the scale by 4, making the result look much more interesting.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"There are many more modifiers. It is recommended to check out the API Reference for a full list of modifiers (and other samplers). Also, be sure to check out the Gallery for more examples.","category":"page"},{"location":"tutorial/#Pipelines","page":"Tutorial","title":"Pipelines","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Once you start composing different noises together with modifiers, the code gets a little un-manageable and harder to read. We can leverage Julia's builtin pipe operator, or more conveniently, the Chain.jl package's @chain macro.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Let's rewrite our last example using @chain","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"@chain mix(OpenSimplex{2}(seed=1), OpenSimplex{2}(seed=2), Perlin{2}(seed=1)) begin\n    scale(_, 0.25)\n    gen_image\nend\n@chain mix(OpenSimplex{2}(seed=1), OpenSimplex{2}(seed=2), Perlin{2}(seed=1)) begin # hide\n    scale(_, 0.25) # hide\n    generate(\"tutorial08\", _) # hide\nend # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: )","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Admittedly, this doesn't look that much better, but the more your noise composition grows, the more this variable-free clear flow of control will be appealing. The remainder of this tutorial, as well as the examples in the Gallery will use @chain, but nothing is forcing you to write the pipeline code manually if this style is not for you.","category":"page"},{"location":"tutorial/#Fractals","page":"Tutorial","title":"Fractals","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Fractals are a type of sampler that applies multiple octaves of a given source sampler, varying their frequency. They make the noise much less regular looking, and offer a good starting point for transforming noises into the desired texture you are trying to simulate, should you be using this library for procedural image generation.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"CoherentNoise has a few different fractal sampler types, all of which will be demonstrated below.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We will start with the following regular noise, and apply different fractal samplers to it:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"@chain OpenSimplex{3}(seed=1) begin\n    gen_image\nend\n@chain OpenSimplex{3}(seed=1) begin # hide\n    generate(\"tutorial09\", _) # hide\nend # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: )","category":"page"},{"location":"tutorial/#FBM","page":"Tutorial","title":"FBM","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The most basic example is that with only a source argument supplied.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"@chain OpenSimplex{3}(seed=1) begin\n    FBM{3}(source=_)\n    gen_image\nend\n@chain OpenSimplex2{3}(seed=1) begin # hide\n    FBM{3}(source=_) # hide\n    generate(\"tutorial10\", _) # hide\nend # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: )","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Already, this is starting to look more natural.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"All fractal samplers have various knobs to tweak to control the output. Please refer to the API Reference for details, but here are some more examples of FBM using our same source sampler:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"@chain OpenSimplex{3}(seed=1) begin\n    FBM{3}(seed=1, source=_, octaves=3)\n    gen_image\nend\n@chain OpenSimplex2{3}(seed=1) begin # hide\n    FBM{3}(seed=1, source=_, octaves=3) # hide\n    generate(\"tutorial11\", _) # hide\nend # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: )","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"@chain OpenSimplex{3}(seed=1) begin\n    FBM{3}(seed=1, source=_, frequency=3)\n    gen_image\nend\n@chain OpenSimplex2{3}(seed=1) begin # hide\n    FBM{3}(seed=1, source=_, frequency=3) # hide\n    generate(\"tutorial12\", _) # hide\nend # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: )","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"@chain OpenSimplex{3}(seed=1) begin\n    FBM{3}(seed=1, source=_, frequency=3, persistence=0.7)\n    gen_image\nend\n@chain OpenSimplex2{3}(seed=1) begin # hide\n    FBM{3}(seed=1, source=_, frequency=3, persistence=0.7) # hide\n    generate(\"tutorial13\", _) # hide\nend # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: )","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"@chain OpenSimplex{3}(seed=1) begin\n    FBM{3}(seed=1, source=_, frequency=3, persistence=0.7, lacunarity=1.2)\n    gen_image\nend\n@chain OpenSimplex2{3}(seed=1) begin # hide\n    FBM{3}(seed=1, source=_, frequency=3, persistence=0.7, lacunarity=1.5) # hide\n    generate(\"tutorial14\", _) # hide\nend # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: )","category":"page"},{"location":"tutorial/#Billow","page":"Tutorial","title":"Billow","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Billow is another fractal sampler type that produces a billowy appearance. It could be used as the basis for a clouds texture, among many other uses. It supports all of the same parameters as FBM. Here is an example:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"@chain OpenSimplex{3}(seed=1) begin\n    Billow{3}(seed=1, source=_, frequency=2.5, persistence=0.55, lacunarity=1.7)\n    gen_image\nend\n@chain OpenSimplex2{3}(seed=1) begin # hide\n    Billow{3}(seed=1, source=_, frequency=2.5, persistence=0.55, lacunarity=1.7) # hide\n    generate(\"tutorial15\", _) # hide\nend # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: )","category":"page"},{"location":"tutorial/#Ridged","page":"Tutorial","title":"Ridged","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Ridged is a fractal (actually a multifractal) sampler type that produces ridges. It could be used as the basis for a a mountainous terrain texture, among many other uses. It supports all of the same parameters as all other fractals, with the addition of an attenuation parameter Here are some examples:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"@chain OpenSimplex{3}(seed=1) begin\n    Ridged{3}(seed=1, source=_, frequency=2.5, persistence=0.4, attenuation=1)\n    gen_image\nend\n@chain OpenSimplex2{3}(seed=1) begin # hide\n    Ridged{3}(seed=1, source=_, frequency=2.5, persistence=0.4, attenuation=1) # hide\n    generate(\"tutorial16\", _) # hide\nend # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: )","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"@chain OpenSimplex2S{3}(seed=1) begin\n    Ridged{3}(seed=1, source=_, octaves=6, frequency=1.8, persistence=0.48)\n    gen_image\nend\n@chain OpenSimplex2S{3}(seed=1) begin # hide\n    Ridged{3}(seed=1, source=_, octaves=6, frequency=1.8, persistence=0.48) # hide\n    generate(\"tutorial17\", _) # hide\nend # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: )","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"There are a couple other fractal types they we didn't go over, but feel free to experiment with them. Their interface is the same as any other fractal type.","category":"page"},{"location":"tutorial/#Adding-color","page":"Tutorial","title":"Adding color","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"CoherentNoise works in combination with ColorSchemes.jl to add color to generated images. To do so, just pass the colorscheme keyword argument to gen_image with any color scheme provided by ColorSchemes.jl, or your own. Adding some color to the last Ridged fractal example looks like this:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"@chain OpenSimplex2S{3}(seed=1) begin\n    Ridged{3}(seed=1, source=_, octaves=6, frequency=1.2, attenuation=1.3, lacunarity=4.5, persistence=0.58)\n    gen_image(_, colorscheme=ColorSchemes.terrain)\nend\n@chain OpenSimplex2S{3}(seed=1) begin # hide\n    Ridged{3}(seed=1, source=_, octaves=6, frequency=1.2, attenuation=1.3, lacunarity=4.5, persistence=0.58) # hide\n    generate(\"tutorial18\", _, colorscheme=ColorSchemes.terrain) # hide\nend # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: )","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Here is the same thing with the noise output negated with the unary - modifier:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"@chain OpenSimplex2S{3}(seed=1) begin\n    Ridged{3}(seed=1, source=_, octaves=6, frequency=1.2, attenuation=1.3, lacunarity=4.5, persistence=0.58)\n    -\n    gen_image(_, colorscheme=ColorSchemes.terrain)\nend\n@chain OpenSimplex2S{3}(seed=1) begin # hide\n    Ridged{3}(seed=1, source=_, octaves=6, frequency=1.2, attenuation=1.3, lacunarity=4.5, persistence=0.58) # hide\n    - # hide\n    generate(\"tutorial19\", _, colorscheme=ColorSchemes.terrain) # hide\nend # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: )","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"That looks pretty interesting. With a bit more work, you could get it to look much more realistic and terrain-like. For example, to make it more arid, you can simply add an abs modifier:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"@chain OpenSimplex2S{3}(seed=1) begin\n    Ridged{3}(seed=1, source=_, octaves=6, frequency=1.2, attenuation=1.3, lacunarity=4.5, persistence=0.58)\n    -\n    abs\n    gen_image(_, colorscheme=ColorSchemes.terrain)\nend\n@chain OpenSimplex2S{3}(seed=1) begin # hide\n    Ridged{3}(seed=1, source=_, octaves=6, frequency=1.2, attenuation=1.3, lacunarity=4.5, persistence=0.58) # hide\n    - # hide\n    abs # hide\n    generate(\"tutorial20\", _, colorscheme=ColorSchemes.terrain) # hide\nend # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: )","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"That concludes the basic tutorial. Feel free to experiment with complex noise pipelines, and submit your results as a pull request to be included in the Gallery section!","category":"page"}]
}
