<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Reference · CoherentNoise.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://mfiano.github.io/CoherentNoise.jl/reference/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="CoherentNoise.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">CoherentNoise.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../overview/">Overview</a></li><li><a class="tocitem" href="../getting_started/">Getting Started</a></li><li><a class="tocitem" href="../tutorial/">Tutorial</a></li><li><a class="tocitem" href="../gallery/">Gallery</a></li><li class="is-active"><a class="tocitem" href>API Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/mfiano/CoherentNoise.jl/blob/main/docs/src/reference.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API-Reference"><a class="docs-heading-anchor" href="#API-Reference">API Reference</a><a id="API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-Reference" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="CoherentNoise.AbstractSampler" href="#CoherentNoise.AbstractSampler"><code>CoherentNoise.AbstractSampler</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Supertype for all samplers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mfiano/CoherentNoise.jl/blob/9a32e0f1afc48f2133fb7c58e1e734e493f30f86/src/common.jl#L1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoherentNoise.FractalSampler" href="#CoherentNoise.FractalSampler"><code>CoherentNoise.FractalSampler</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Supertype for all fractal samplers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mfiano/CoherentNoise.jl/blob/9a32e0f1afc48f2133fb7c58e1e734e493f30f86/src/common.jl#L11-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoherentNoise.ModifierSampler" href="#CoherentNoise.ModifierSampler"><code>CoherentNoise.ModifierSampler</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Supertype for all modifier samplers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mfiano/CoherentNoise.jl/blob/9a32e0f1afc48f2133fb7c58e1e734e493f30f86/src/common.jl#L21-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoherentNoise.NoiseSampler" href="#CoherentNoise.NoiseSampler"><code>CoherentNoise.NoiseSampler</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Supertype for all noise algorithm samplers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mfiano/CoherentNoise.jl/blob/9a32e0f1afc48f2133fb7c58e1e734e493f30f86/src/common.jl#L6-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoherentNoise.PatternSampler" href="#CoherentNoise.PatternSampler"><code>CoherentNoise.PatternSampler</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Supertype for all pattern samplers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mfiano/CoherentNoise.jl/blob/9a32e0f1afc48f2133fb7c58e1e734e493f30f86/src/common.jl#L16-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:*-Union{Tuple{S2}, Tuple{S1}, Tuple{N2}, Tuple{N1}, Tuple{S1, S2}} where {N1, N2, S1&lt;:AbstractSampler{N1}, S2&lt;:AbstractSampler{N2}}" href="#Base.:*-Union{Tuple{S2}, Tuple{S1}, Tuple{N2}, Tuple{N1}, Tuple{S1, S2}} where {N1, N2, S1&lt;:AbstractSampler{N1}, S2&lt;:AbstractSampler{N2}}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">*(x::AbstractSampler, y::AbstractSampler)</code></pre><p>Construct a modifier sampler that outputs the product of the outputs samplers <code>x</code> and <code>y</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mfiano/CoherentNoise.jl/blob/9a32e0f1afc48f2133fb7c58e1e734e493f30f86/src/mod_mul.jl#L7-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:*-Union{Tuple{S}, Tuple{N}, Tuple{S, Real}} where {N, S&lt;:AbstractSampler{N}}" href="#Base.:*-Union{Tuple{S}, Tuple{N}, Tuple{S, Real}} where {N, S&lt;:AbstractSampler{N}}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">*(x::AbstractSampler, y::Real)</code></pre><p>Construct a modifier sampler that outputs the product of the output of sampler <code>x</code> by the scalar <code>y</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mfiano/CoherentNoise.jl/blob/9a32e0f1afc48f2133fb7c58e1e734e493f30f86/src/mod_mul.jl#L17-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:+-Union{Tuple{S2}, Tuple{S1}, Tuple{N2}, Tuple{N1}, Tuple{S1, S2}} where {N1, N2, S1&lt;:AbstractSampler{N1}, S2&lt;:AbstractSampler{N2}}" href="#Base.:+-Union{Tuple{S2}, Tuple{S1}, Tuple{N2}, Tuple{N1}, Tuple{S1, S2}} where {N1, N2, S1&lt;:AbstractSampler{N1}, S2&lt;:AbstractSampler{N2}}"><code>Base.:+</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">+(x::AbstractSampler, y::AbstractSampler)</code></pre><p>Construct a modifier sampler that outputs the sum of the outputs of samplers <code>x</code> and <code>y</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mfiano/CoherentNoise.jl/blob/9a32e0f1afc48f2133fb7c58e1e734e493f30f86/src/mod_add.jl#L7-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:+-Union{Tuple{S}, Tuple{N}, Tuple{S, Real}} where {N, S&lt;:AbstractSampler{N}}" href="#Base.:+-Union{Tuple{S}, Tuple{N}, Tuple{S, Real}} where {N, S&lt;:AbstractSampler{N}}"><code>Base.:+</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">+(x::AbstractSampler, y::Real)</code></pre><p>Construct a modifier sampler that outputs the sum of the output of sampler <code>x</code> and the scalar <code>y</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mfiano/CoherentNoise.jl/blob/9a32e0f1afc48f2133fb7c58e1e734e493f30f86/src/mod_add.jl#L17-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:--Union{Tuple{S2}, Tuple{S1}, Tuple{N2}, Tuple{N1}, Tuple{S1, S2}} where {N1, N2, S1&lt;:AbstractSampler{N1}, S2&lt;:AbstractSampler{N2}}" href="#Base.:--Union{Tuple{S2}, Tuple{S1}, Tuple{N2}, Tuple{N1}, Tuple{S1, S2}} where {N1, N2, S1&lt;:AbstractSampler{N1}, S2&lt;:AbstractSampler{N2}}"><code>Base.:-</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">-(x::AbstractSampler, y::AbstractSampler)</code></pre><p>Construct a modifier sampler that outputs the difference of the outputs of samplers <code>x</code> and <code>y</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mfiano/CoherentNoise.jl/blob/9a32e0f1afc48f2133fb7c58e1e734e493f30f86/src/mod_sub.jl#L7-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:--Union{Tuple{S}, Tuple{N}, Tuple{S, Real}} where {N, S&lt;:AbstractSampler{N}}" href="#Base.:--Union{Tuple{S}, Tuple{N}, Tuple{S, Real}} where {N, S&lt;:AbstractSampler{N}}"><code>Base.:-</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">-(x::AbstractSampler, y::Real)</code></pre><p>Construct a modifier sampler that outputs the difference of the output of sampler <code>x</code> and the scalar <code>y</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mfiano/CoherentNoise.jl/blob/9a32e0f1afc48f2133fb7c58e1e734e493f30f86/src/mod_sub.jl#L17-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:--Union{Tuple{S}, Tuple{N}} where {N, S&lt;:AbstractSampler{N}}" href="#Base.:--Union{Tuple{S}, Tuple{N}} where {N, S&lt;:AbstractSampler{N}}"><code>Base.:-</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">-(x::AbstractSampler)</code></pre><p>Construct a modifier sampler that outputs the negated output of sampler <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mfiano/CoherentNoise.jl/blob/9a32e0f1afc48f2133fb7c58e1e734e493f30f86/src/mod_sub.jl#L27-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:/-Union{Tuple{S2}, Tuple{S1}, Tuple{N2}, Tuple{N1}, Tuple{S1, S2}} where {N1, N2, S1&lt;:AbstractSampler{N1}, S2&lt;:AbstractSampler{N2}}" href="#Base.:/-Union{Tuple{S2}, Tuple{S1}, Tuple{N2}, Tuple{N1}, Tuple{S1, S2}} where {N1, N2, S1&lt;:AbstractSampler{N1}, S2&lt;:AbstractSampler{N2}}"><code>Base.:/</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">/(x::AbstractSampler, y::AbstractSampler)</code></pre><p>Construct a modifier sampler that performs division of the output of sampler <code>x</code> by the output of sampler <code>y</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mfiano/CoherentNoise.jl/blob/9a32e0f1afc48f2133fb7c58e1e734e493f30f86/src/mod_div.jl#L7-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:/-Union{Tuple{S}, Tuple{N}, Tuple{S, Real}} where {N, S&lt;:AbstractSampler{N}}" href="#Base.:/-Union{Tuple{S}, Tuple{N}, Tuple{S, Real}} where {N, S&lt;:AbstractSampler{N}}"><code>Base.:/</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">/(x::AbstractSampler, y::Real)</code></pre><p>Construct a modifier sampler that performs division of the output of sampler <code>x</code> by the scalar <code>y</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mfiano/CoherentNoise.jl/blob/9a32e0f1afc48f2133fb7c58e1e734e493f30f86/src/mod_div.jl#L18-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:^-Union{Tuple{S}, Tuple{N}, Tuple{S, Real}} where {N, S&lt;:AbstractSampler{N}}" href="#Base.:^-Union{Tuple{S}, Tuple{N}, Tuple{S, Real}} where {N, S&lt;:AbstractSampler{N}}"><code>Base.:^</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">^(x::AbstractSampler, y::Real)</code></pre><p>Construct a modifier sampler that raises the output of sampler <code>x</code> to the power of the scalar <code>y</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mfiano/CoherentNoise.jl/blob/9a32e0f1afc48f2133fb7c58e1e734e493f30f86/src/mod_pow.jl#L7-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Math.clamp-Union{Tuple{H}, Tuple{L}, Tuple{S}, Tuple{N2}, Tuple{N1}, Tuple{N}, Tuple{S, L, H}} where {N, N1, N2, S&lt;:AbstractSampler{N}, L&lt;:AbstractSampler{N1}, H&lt;:AbstractSampler{N2}}" href="#Base.Math.clamp-Union{Tuple{H}, Tuple{L}, Tuple{S}, Tuple{N2}, Tuple{N1}, Tuple{N}, Tuple{S, L, H}} where {N, N1, N2, S&lt;:AbstractSampler{N}, L&lt;:AbstractSampler{N1}, H&lt;:AbstractSampler{N2}}"><code>Base.Math.clamp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">clamp(x::AbstractSampler, lo::AbstractSampler, hi::AbstractSampler)</code></pre><p>Construct a modifier sampler that clamps the output of sampler <code>x</code> to be within the range of of output values from samplers <code>lo</code> and <code>hi</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mfiano/CoherentNoise.jl/blob/9a32e0f1afc48f2133fb7c58e1e734e493f30f86/src/mod_clamp.jl#L8-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Math.clamp-Union{Tuple{S}, Tuple{N}, Tuple{S, Real}, Tuple{S, Real, Real}} where {N, S&lt;:AbstractSampler{N}}" href="#Base.Math.clamp-Union{Tuple{S}, Tuple{N}, Tuple{S, Real}, Tuple{S, Real, Real}} where {N, S&lt;:AbstractSampler{N}}"><code>Base.Math.clamp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">clamp(x::AbstractSampler, lo::Real=-1.0, hi::Real=1.0)</code></pre><p>Construct a modifier sampler that clamps the output of sampler <code>x</code> to be within the range of of the scalars <code>lo</code> and <code>hi</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mfiano/CoherentNoise.jl/blob/9a32e0f1afc48f2133fb7c58e1e734e493f30f86/src/mod_clamp.jl#L22-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.abs-Union{Tuple{S}, Tuple{N}} where {N, S&lt;:AbstractSampler{N}}" href="#Base.abs-Union{Tuple{S}, Tuple{N}} where {N, S&lt;:AbstractSampler{N}}"><code>Base.abs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">abs(x::AbstractSampler)</code></pre><p>Construct a modifier sampler that outputs the absolute value of its source when it is sampled from.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mfiano/CoherentNoise.jl/blob/9a32e0f1afc48f2133fb7c58e1e734e493f30f86/src/mod_abs.jl#L6-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.copysign-Union{Tuple{S2}, Tuple{S1}, Tuple{N2}, Tuple{N1}, Tuple{S1, S2}} where {N1, N2, S1&lt;:AbstractSampler{N1}, S2&lt;:AbstractSampler{N2}}" href="#Base.copysign-Union{Tuple{S2}, Tuple{S1}, Tuple{N2}, Tuple{N1}, Tuple{S1, S2}} where {N1, N2, S1&lt;:AbstractSampler{N1}, S2&lt;:AbstractSampler{N2}}"><code>Base.copysign</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">copysign(x::AbstractSampler, y::AbstractSampler)</code></pre><p>Construct a modifier sampler that outputs the value of sampling from <code>x</code> with the sign copied from the value of sampling from <code>y</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mfiano/CoherentNoise.jl/blob/9a32e0f1afc48f2133fb7c58e1e734e493f30f86/src/mod_copysign.jl#L7-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.max-Union{Tuple{S2}, Tuple{S1}, Tuple{N2}, Tuple{N1}, Tuple{S1, S2}} where {N1, N2, S1&lt;:AbstractSampler{N1}, S2&lt;:AbstractSampler{N2}}" href="#Base.max-Union{Tuple{S2}, Tuple{S1}, Tuple{N2}, Tuple{N1}, Tuple{S1, S2}} where {N1, N2, S1&lt;:AbstractSampler{N1}, S2&lt;:AbstractSampler{N2}}"><code>Base.max</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">max(x::AbstractSampler, y::AbstractSampler)</code></pre><p>Construct a modifier sampler that outputs the maximum value of the outputs of sampling from samplers <code>x</code> and <code>y</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mfiano/CoherentNoise.jl/blob/9a32e0f1afc48f2133fb7c58e1e734e493f30f86/src/mod_max.jl#L7-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.min-Union{Tuple{S2}, Tuple{S1}, Tuple{N2}, Tuple{N1}, Tuple{S1, S2}} where {N1, N2, S1&lt;:AbstractSampler{N1}, S2&lt;:AbstractSampler{N2}}" href="#Base.min-Union{Tuple{S2}, Tuple{S1}, Tuple{N2}, Tuple{N1}, Tuple{S1, S2}} where {N1, N2, S1&lt;:AbstractSampler{N1}, S2&lt;:AbstractSampler{N2}}"><code>Base.min</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">min(x::AbstractSampler, y::AbstractSampler)</code></pre><p>Construct a modifier sampler that outputs the minimum value of the outputs of sampling from samplers <code>x</code> and <code>y</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mfiano/CoherentNoise.jl/blob/9a32e0f1afc48f2133fb7c58e1e734e493f30f86/src/mod_min.jl#L7-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.muladd-Union{Tuple{S}, Tuple{N}, Tuple{S, Real}, Tuple{S, Real, Real}} where {N, S&lt;:AbstractSampler{N}}" href="#Base.muladd-Union{Tuple{S}, Tuple{N}, Tuple{S, Real}, Tuple{S, Real, Real}} where {N, S&lt;:AbstractSampler{N}}"><code>Base.muladd</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">muladd(x::AbstractSampler, strength::Real=1.0, bias::Real=0.0)</code></pre><p>Construct a modifier sampler that performs multiplies the output of sampler <code>x</code> by the scalar <code>strength</code>, followed by adding the scalar <code>bias</code>. sampler <code>y</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mfiano/CoherentNoise.jl/blob/9a32e0f1afc48f2133fb7c58e1e734e493f30f86/src/mod_muladd.jl#L8-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoherentNoise.billow_fractal_2d-Tuple{}" href="#CoherentNoise.billow_fractal_2d-Tuple{}"><code>CoherentNoise.billow_fractal_2d</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">billow_fractal_2d(; kwargs...)</code></pre><p>Construct a sampler that outputs a 2-dimensional billow fractal noise when it is sampled from.</p><p><strong>Arguments</strong></p><ul><li><p><code>seed=0</code>: An integer used to seed the random number generator for this sampler.</p></li><li><p><code>source::AbstractSampler=opensimplex2s_2d()</code>: A 2-dimensional sampler instance to use as the source of the fractal.</p></li><li><p><code>octaves=4</code>: An integer between 1 and 32, denoting the number of octaves to apply.</p></li><li><p><code>frequency=1.0</code>: The frequency of the first octave&#39;s signal.</p></li><li><p><code>lacunarity=2.0</code>: A multiplier that determines how quickly the frequency increases for successive octaves.</p></li><li><p><code>persistence=0.5</code>: A multiplier that determines how quickly the amplitude diminishes for successive octaves.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mfiano/CoherentNoise.jl/blob/9a32e0f1afc48f2133fb7c58e1e734e493f30f86/src/fractal_billow.jl#L18-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoherentNoise.billow_fractal_3d-Tuple{}" href="#CoherentNoise.billow_fractal_3d-Tuple{}"><code>CoherentNoise.billow_fractal_3d</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">billow_fractal_3d(; kwargs...)</code></pre><p>Construct a sampler that outputs a 3-dimensional billow fractal noise when it is sampled from.</p><p><strong>Arguments</strong></p><ul><li><p><code>seed=0</code>: An integer used to seed the random number generator for this sampler.</p></li><li><p><code>source::AbstractSampler=opensimplex2s_3d()</code>: A 3-dimensional sampler instance to use as the source of the fractal.</p></li><li><p><code>octaves=4</code>: An integer between 1 and 32, denoting the number of octaves to apply.</p></li><li><p><code>frequency=1.0</code>: The frequency of the first octave&#39;s signal.</p></li><li><p><code>lacunarity=2.0</code>: A multiplier that determines how quickly the frequency increases for successive octaves.</p></li><li><p><code>persistence=0.5</code>: A multiplier that determines how quickly the amplitude diminishes for successive octaves.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mfiano/CoherentNoise.jl/blob/9a32e0f1afc48f2133fb7c58e1e734e493f30f86/src/fractal_billow.jl#L51-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoherentNoise.billow_fractal_4d-Tuple{}" href="#CoherentNoise.billow_fractal_4d-Tuple{}"><code>CoherentNoise.billow_fractal_4d</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">billow_fractal_4d(; kwargs...)</code></pre><p>Construct a sampler that outputs a 4-dimensional billow fractal noise when it is sampled from.</p><p><strong>Arguments</strong></p><ul><li><p><code>seed=0</code>: An integer used to seed the random number generator for this sampler.</p></li><li><p><code>source::AbstractSampler=opensimplex2s_4d()</code>: A 4-dimensional sampler instance to use as the source of the fractal.</p></li><li><p><code>octaves=4</code>: An integer between 1 and 32, denoting the number of octaves to apply.</p></li><li><p><code>frequency=1.0</code>: The frequency of the first octave&#39;s signal.</p></li><li><p><code>lacunarity=2.0</code>: A multiplier that determines how quickly the frequency increases for successive octaves.</p></li><li><p><code>persistence=0.5</code>: A multiplier that determines how quickly the amplitude diminishes for successive octaves.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mfiano/CoherentNoise.jl/blob/9a32e0f1afc48f2133fb7c58e1e734e493f30f86/src/fractal_billow.jl#L84-L105">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoherentNoise.cache-Union{Tuple{S}, Tuple{N}} where {N, S&lt;:AbstractSampler{N}}" href="#CoherentNoise.cache-Union{Tuple{S}, Tuple{N}} where {N, S&lt;:AbstractSampler{N}}"><code>CoherentNoise.cache</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cache(x::AbstractSampler)</code></pre><p>Construct a modifier sampler that caches the set of the input coordinates and their corresponding output value of its source sampler. If the input coordinates differs from the previously cached output, the cache is invalidated and the new output is cached.</p><p>Caching is useful if a sampler is used as a source for multiple modifiers. Without caching, the duplicated input sources would redundantly compute the same outputs, which would be expensive, especially if long pipelines share a long subgraph.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mfiano/CoherentNoise.jl/blob/9a32e0f1afc48f2133fb7c58e1e734e493f30f86/src/mod_cache.jl#L9-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoherentNoise.checkered_2d-Tuple{}" href="#CoherentNoise.checkered_2d-Tuple{}"><code>CoherentNoise.checkered_2d</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">checkered_2d(; kwargs...)</code></pre><p>Construct a sampler that outputs values in a checkerboard-like pattern when it is sampled from.</p><p>That is, output values will only ever be -1.0 or 1.0.</p><p><strong>Arguments</strong></p><ul><li><code>seed=0</code>: An integer used to seed the random number generator for this sampler.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mfiano/CoherentNoise.jl/blob/9a32e0f1afc48f2133fb7c58e1e734e493f30f86/src/pattern_checkered_2d.jl#L5-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoherentNoise.constant_1d-Tuple{}" href="#CoherentNoise.constant_1d-Tuple{}"><code>CoherentNoise.constant_1d</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constant_1d(; kwargs...)</code></pre><p>Construct a sampler that constantly outputs <code>value</code> each time it is sampled from.</p><p>This is useful for debugging and applications where you need to combine a constant value.</p><p><strong>Arguments</strong></p><ul><li><p><code>seed=0</code>: An integer used to seed the random number generator for this sampler.</p></li><li><p><code>value=0.0</code>: A constant value to emit each time this sampler is sampled from.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mfiano/CoherentNoise.jl/blob/9a32e0f1afc48f2133fb7c58e1e734e493f30f86/src/pattern_constant_1d.jl#L6-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoherentNoise.curve-Union{Tuple{S}, Tuple{N}, Tuple{S, Vector{Pair{Float64, Float64}}}} where {N, S&lt;:AbstractSampler{N}}" href="#CoherentNoise.curve-Union{Tuple{S}, Tuple{N}, Tuple{S, Vector{Pair{Float64, Float64}}}} where {N, S&lt;:AbstractSampler{N}}"><code>CoherentNoise.curve</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">curve(x::AbstractSampler, points::Vector{Pair{Float64,Float64}})</code></pre><p>Construct a modifier sampler that outputs the result of sampling from <code>x</code> after remapping its output to an arbitrary curve.</p><p>The curve is defined by a <code>Vector</code> of <code>Pair</code>s given by <code>points</code>. Each pair of points represents an input and output number. The curve is a cubic spline, and so <code>points</code> must contain a list of four point pairs at a minimum. Additionally, no two point pairs can contain the same input point value.</p><p>When sampling from sampler <code>x</code>, the output is evaluated using the curve data, and maps it to a new output value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mfiano/CoherentNoise.jl/blob/9a32e0f1afc48f2133fb7c58e1e734e493f30f86/src/mod_curve.jl#L7-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoherentNoise.cylinders_2d-Tuple{}" href="#CoherentNoise.cylinders_2d-Tuple{}"><code>CoherentNoise.cylinders_2d</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cylinders_2d(; kwargs...)</code></pre><p>Construct a sampler that outputs values that form a pattern representing concentric cylinders when it is sampled from.</p><p><strong>Arguments</strong></p><ul><li><p><code>seed=0</code>: An integer used to seed the random number generator for this sampler.</p></li><li><p><code>frequency=1.0</code>: The frequency of the signal, which controls how small or large the cylinders are.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mfiano/CoherentNoise.jl/blob/9a32e0f1afc48f2133fb7c58e1e734e493f30f86/src/pattern_cylinders_2d.jl#L6-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoherentNoise.fbm_fractal_2d-Tuple{}" href="#CoherentNoise.fbm_fractal_2d-Tuple{}"><code>CoherentNoise.fbm_fractal_2d</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fbm_fractal_2d(; kwargs...)</code></pre><p>Construct a sampler that outputs a 2-dimensional fractional Brownian motion fractal noise when it is sampled from.</p><p><strong>Arguments</strong></p><ul><li><p><code>seed=0</code>: An integer used to seed the random number generator for this sampler.</p></li><li><p><code>source::AbstractSampler=opensimplex2_2d()</code>: A 2-dimensional sampler instance to use as the source of the fractal.</p></li><li><p><code>octaves=4</code>: An integer between 1 and 32, denoting the number of octaves to apply.</p></li><li><p><code>frequency=1.0</code>: The frequency of the first octave&#39;s signal.</p></li><li><p><code>lacunarity=2.0</code>: A multiplier that determines how quickly the frequency increases for successive octaves.</p></li><li><p><code>persistence=0.5</code>: A multiplier that determines how quickly the amplitude diminishes for successive octaves.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mfiano/CoherentNoise.jl/blob/9a32e0f1afc48f2133fb7c58e1e734e493f30f86/src/fractal_fbm.jl#L18-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoherentNoise.fbm_fractal_3d-Tuple{}" href="#CoherentNoise.fbm_fractal_3d-Tuple{}"><code>CoherentNoise.fbm_fractal_3d</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fbm_fractal_3d(; kwargs...)</code></pre><p>Construct a sampler that outputs a 3-dimensional fractional Brownian motion fractal noise when it is sampled from.</p><p><strong>Arguments</strong></p><ul><li><p><code>seed=0</code>: An integer used to seed the random number generator for this sampler.</p></li><li><p><code>source::AbstractSampler=opensimplex2_3d()</code>: A 3-dimensional sampler instance to use as the source of the fractal.</p></li><li><p><code>octaves=4</code>: An integer between 1 and 32, denoting the number of octaves to apply.</p></li><li><p><code>frequency=1.0</code>: The frequency of the first octave&#39;s signal.</p></li><li><p><code>lacunarity=2.0</code>: A multiplier that determines how quickly the frequency increases for successive octaves.</p></li><li><p><code>persistence=0.5</code>: A multiplier that determines how quickly the amplitude diminishes for successive octaves.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mfiano/CoherentNoise.jl/blob/9a32e0f1afc48f2133fb7c58e1e734e493f30f86/src/fractal_fbm.jl#L52-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoherentNoise.fbm_fractal_4d-Tuple{}" href="#CoherentNoise.fbm_fractal_4d-Tuple{}"><code>CoherentNoise.fbm_fractal_4d</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fbm_fractal_4d(; kwargs...)</code></pre><p>Construct a sampler that outputs a 4-dimensional fractional Brownian motion fractal noise when it is sampled from.</p><p><strong>Arguments</strong></p><ul><li><p><code>seed=0</code>: An integer used to seed the random number generator for this sampler.</p></li><li><p><code>source::AbstractSampler=opensimplex2_4d()</code>: A 4-dimensional sampler instance to use as the source of the fractal.</p></li><li><p><code>octaves=4</code>: An integer between 1 and 32, denoting the number of octaves to apply.</p></li><li><p><code>frequency=1.0</code>: The frequency of the first octave&#39;s signal.</p></li><li><p><code>lacunarity=2.0</code>: A multiplier that determines how quickly the frequency increases for successive octaves.</p></li><li><p><code>persistence=0.5</code>: A multiplier that determines how quickly the amplitude diminishes for successive octaves.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mfiano/CoherentNoise.jl/blob/9a32e0f1afc48f2133fb7c58e1e734e493f30f86/src/fractal_fbm.jl#L86-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoherentNoise.gen_image-Union{Tuple{S}, Tuple{N}} where {N, S&lt;:AbstractSampler{N}}" href="#CoherentNoise.gen_image-Union{Tuple{S}, Tuple{N}} where {N, S&lt;:AbstractSampler{N}}"><code>CoherentNoise.gen_image</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gen_image(sampler::AbstractSampler; kwargs...)</code></pre><p>Construct a 2-dimensional array of <code>ColorTypes.RGB</code> values, suitable for writing to disk as an image file.</p><p><strong>Arguments</strong></p><ul><li><p><code>sampler::AbstractSampler</code>: Any instance of a sampler. The sampler is sampled using each pixel coordinates as the X and Y input coordinates, and random Z and W coordinates for 3 and 4-dimensional samplers.</p></li><li><p><code>w::Integer=1024</code>: The width in pixels of the image array to generate.</p></li><li><p><code>h::Integer=1024</code>: The height in pixels of the image array to generate.</p></li><li><p><code>xbounds::NTuple{2,Float64}=(-1.0, 1.0)</code>: The bounds along the X axis to sample coordinates from. This remaps pixel coordinates to this range to be used for the input coordinates to sample with.</p></li><li><p><code>ybounds::NTuple{2,Float64}=(-1.0, 1.0)</code>: The bounds along the Y axis to sample coordinates from. This remaps pixel coordinates to this range to be used for the input coordinates to sample with.</p></li><li><p><code>colorscheme=nothing</code>: A <code>ColorSchemes.ColorScheme</code> object to colorize the image with, or <code>nothing</code>.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mfiano/CoherentNoise.jl/blob/9a32e0f1afc48f2133fb7c58e1e734e493f30f86/src/common.jl#L101-L127">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoherentNoise.hybrid_fractal_2d-Tuple{}" href="#CoherentNoise.hybrid_fractal_2d-Tuple{}"><code>CoherentNoise.hybrid_fractal_2d</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hybrid_fractal_2d(; kwargs...)</code></pre><p>Construct a sampler that outputs a 2-dimensional hybrid multifractal noise when it is sampled from.</p><p><strong>Arguments</strong></p><ul><li><p><code>seed=0</code>: An integer used to seed the random number generator for this sampler.</p></li><li><p><code>source::AbstractSampler=opensimplex2s_2d()</code>: A 2-dimensional sampler instance to use as the source of the fractal.</p></li><li><p><code>octaves=4</code>: An integer between 1 and 32, denoting the number of octaves to apply.</p></li><li><p><code>frequency=1.0</code>: The frequency of the first octave&#39;s signal.</p></li><li><p><code>lacunarity=2.0</code>: A multiplier that determines how quickly the frequency increases for successive octaves.</p></li><li><p><code>persistence=0.25</code>: A multiplier that determines how quickly the amplitude diminishes for successive octaves.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mfiano/CoherentNoise.jl/blob/9a32e0f1afc48f2133fb7c58e1e734e493f30f86/src/fractal_hybrid.jl#L18-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoherentNoise.hybrid_fractal_3d-Tuple{}" href="#CoherentNoise.hybrid_fractal_3d-Tuple{}"><code>CoherentNoise.hybrid_fractal_3d</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hybrid_fractal_3d(; kwargs...)</code></pre><p>Construct a sampler that outputs a 3-dimensional hybrid multifractal noise when it is sampled from.</p><p><strong>Arguments</strong></p><ul><li><p><code>seed=0</code>: An integer used to seed the random number generator for this sampler.</p></li><li><p><code>source::AbstractSampler=opensimplex2s_3d()</code>: A 3-dimensional sampler instance to use as the source of the fractal.</p></li><li><p><code>octaves=4</code>: An integer between 1 and 32, denoting the number of octaves to apply.</p></li><li><p><code>frequency=1.0</code>: The frequency of the first octave&#39;s signal.</p></li><li><p><code>lacunarity=2.0</code>: A multiplier that determines how quickly the frequency increases for successive octaves.</p></li><li><p><code>persistence=0.25</code>: A multiplier that determines how quickly the amplitude diminishes for successive octaves.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mfiano/CoherentNoise.jl/blob/9a32e0f1afc48f2133fb7c58e1e734e493f30f86/src/fractal_hybrid.jl#L51-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoherentNoise.hybrid_fractal_4d-Tuple{}" href="#CoherentNoise.hybrid_fractal_4d-Tuple{}"><code>CoherentNoise.hybrid_fractal_4d</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hybrid_fractal_4d(; kwargs...)</code></pre><p>Construct a sampler that outputs a 4-dimensional hybrid multifractal noise when it is sampled from.</p><p><strong>Arguments</strong></p><ul><li><p><code>seed=0</code>: An integer used to seed the random number generator for this sampler.</p></li><li><p><code>source::AbstractSampler=opensimplex2s_4d()</code>: A 4-dimensional sampler instance to use as the source of the fractal.</p></li><li><p><code>octaves=4</code>: An integer between 1 and 32, denoting the number of octaves to apply.</p></li><li><p><code>frequency=1.0</code>: The frequency of the first octave&#39;s signal.</p></li><li><p><code>lacunarity=2.0</code>: A multiplier that determines how quickly the frequency increases for successive octaves.</p></li><li><p><code>persistence=0.25</code>: A multiplier that determines how quickly the amplitude diminishes for successive octaves.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mfiano/CoherentNoise.jl/blob/9a32e0f1afc48f2133fb7c58e1e734e493f30f86/src/fractal_hybrid.jl#L84-L105">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoherentNoise.mix-Union{Tuple{C}, Tuple{S2}, Tuple{S1}, Tuple{N3}, Tuple{N2}, Tuple{N1}, Tuple{S1, S2, C}} where {N1, N2, N3, S1&lt;:AbstractSampler{N1}, S2&lt;:AbstractSampler{N2}, C&lt;:AbstractSampler{N3}}" href="#CoherentNoise.mix-Union{Tuple{C}, Tuple{S2}, Tuple{S1}, Tuple{N3}, Tuple{N2}, Tuple{N1}, Tuple{S1, S2, C}} where {N1, N2, N3, S1&lt;:AbstractSampler{N1}, S2&lt;:AbstractSampler{N2}, C&lt;:AbstractSampler{N3}}"><code>CoherentNoise.mix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mix(x::AbstractSampler, y::AbstractSampler, t::AbstractSampler)</code></pre><p>Construct a modifier sampler that outputs the result of linearly interpolating the output of samplers <code>x</code> and <code>y</code> by the output of sampler <code>t</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mfiano/CoherentNoise.jl/blob/9a32e0f1afc48f2133fb7c58e1e734e493f30f86/src/mod_mix.jl#L8-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoherentNoise.mix-Union{Tuple{S2}, Tuple{S1}, Tuple{N2}, Tuple{N1}, Tuple{S1, S2, Real}} where {N1, N2, S1&lt;:AbstractSampler{N1}, S2&lt;:AbstractSampler{N2}}" href="#CoherentNoise.mix-Union{Tuple{S2}, Tuple{S1}, Tuple{N2}, Tuple{N1}, Tuple{S1, S2, Real}} where {N1, N2, S1&lt;:AbstractSampler{N1}, S2&lt;:AbstractSampler{N2}}"><code>CoherentNoise.mix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mix(x::AbstractSampler, y::AbstractSampler, t::Scalar)</code></pre><p>Construct a modifier sampler that outputs the result of linearly interpolating the output of samplers <code>x</code> and <code>y</code> by the scalar <code>t</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mfiano/CoherentNoise.jl/blob/9a32e0f1afc48f2133fb7c58e1e734e493f30f86/src/mod_mix.jl#L23-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoherentNoise.multi_fractal_2d-Tuple{}" href="#CoherentNoise.multi_fractal_2d-Tuple{}"><code>CoherentNoise.multi_fractal_2d</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">multi_fractal_2d(; kwargs...)</code></pre><p>Construct a sampler that outputs a 2-dimensional multifractal noise when it is sampled from.</p><p><strong>Arguments</strong></p><ul><li><p><code>seed=0</code>: An integer used to seed the random number generator for this sampler.</p></li><li><p><code>source::AbstractSampler=opensimplex2s_2d()</code>: A 2-dimensional sampler instance to use as the source of the fractal.</p></li><li><p><code>octaves=4</code>: An integer between 1 and 32, denoting the number of octaves to apply.</p></li><li><p><code>frequency=1.0</code>: The frequency of the first octave&#39;s signal.</p></li><li><p><code>lacunarity=2.0</code>: A multiplier that determines how quickly the frequency increases for successive octaves.</p></li><li><p><code>persistence=0.5</code>: A multiplier that determines how quickly the amplitude diminishes for successive octaves.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mfiano/CoherentNoise.jl/blob/9a32e0f1afc48f2133fb7c58e1e734e493f30f86/src/fractal_multi.jl#L18-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoherentNoise.multi_fractal_3d-Tuple{}" href="#CoherentNoise.multi_fractal_3d-Tuple{}"><code>CoherentNoise.multi_fractal_3d</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">multi_fractal_3d(; kwargs...)</code></pre><p>Construct a sampler that outputs a 3-dimensional multifractal noise when it is sampled from.</p><p><strong>Arguments</strong></p><ul><li><p><code>seed=0</code>: An integer used to seed the random number generator for this sampler.</p></li><li><p><code>source::AbstractSampler=opensimplex2s_3d()</code>: A 3-dimensional sampler instance to use as the source of the fractal.</p></li><li><p><code>octaves=4</code>: An integer between 1 and 32, denoting the number of octaves to apply.</p></li><li><p><code>frequency=1.0</code>: The frequency of the first octave&#39;s signal.</p></li><li><p><code>lacunarity=2.0</code>: A multiplier that determines how quickly the frequency increases for successive octaves.</p></li><li><p><code>persistence=0.5</code>: A multiplier that determines how quickly the amplitude diminishes for successive octaves.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mfiano/CoherentNoise.jl/blob/9a32e0f1afc48f2133fb7c58e1e734e493f30f86/src/fractal_multi.jl#L51-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoherentNoise.multi_fractal_4d-Tuple{}" href="#CoherentNoise.multi_fractal_4d-Tuple{}"><code>CoherentNoise.multi_fractal_4d</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">multi_fractal_4d(; kwargs...)</code></pre><p>Construct a sampler that outputs a 4-dimensional multifractal noise when it is sampled from.</p><p><strong>Arguments</strong></p><ul><li><p><code>seed=0</code>: An integer used to seed the random number generator for this sampler.</p></li><li><p><code>source::AbstractSampler=opensimplex2s_4d()</code>: A 4-dimensional sampler instance to use as the source of the fractal.</p></li><li><p><code>octaves=4</code>: An integer between 1 and 32, denoting the number of octaves to apply.</p></li><li><p><code>frequency=1.0</code>: The frequency of the first octave&#39;s signal.</p></li><li><p><code>lacunarity=2.0</code>: A multiplier that determines how quickly the frequency increases for successive octaves.</p></li><li><p><code>persistence=0.5</code>: A multiplier that determines how quickly the amplitude diminishes for successive octaves.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mfiano/CoherentNoise.jl/blob/9a32e0f1afc48f2133fb7c58e1e734e493f30f86/src/fractal_multi.jl#L84-L105">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoherentNoise.opensimplex2_2d-Tuple{}" href="#CoherentNoise.opensimplex2_2d-Tuple{}"><code>CoherentNoise.opensimplex2_2d</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">opensimplex2_2d(; kwargs...)</code></pre><p>Construct a sampler that outputs 2-dimensional OpenSimplex2 noise when it is sampled from.</p><p><strong>Arguments</strong></p><ul><li><p><code>seed=0</code>: An integer used to seed the random number generator for this sampler.</p></li><li><p><code>orient=nothing</code>: Either the symbol <code>:x</code> or the value <code>nothing</code>:</p><ul><li><p><code>:x</code>: The noise space will be re-oriented with the Y axis pointing down the main diagonal to improve visual isotropy.</p></li><li><p><code>nothing</code>: Use the standard orientation.</p></li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mfiano/CoherentNoise.jl/blob/9a32e0f1afc48f2133fb7c58e1e734e493f30f86/src/noise_opensimplex2_2d.jl#L33-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoherentNoise.opensimplex2_3d-Tuple{}" href="#CoherentNoise.opensimplex2_3d-Tuple{}"><code>CoherentNoise.opensimplex2_3d</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">opensimplex2_3d(; kwargs...)</code></pre><p>Construct a sampler that outputs 3-dimensional OpenSimplex2 noise when it is sampled from.</p><p><strong>Arguments</strong></p><ul><li><p><code>seed=0</code>: An integer used to seed the random number generator for this sampler.</p></li><li><p><code>orient=nothing</code>: One of the following symbols or the value <code>nothing</code>:</p><ul><li><p><code>:x</code>: The noise space will be re-oriented with the Y axis pointing down the main diagonal to improve visual isotropy.</p></li><li><p><code>:xy</code>: Re-orient the noise space to have better visual isotropy in the XY plane.</p></li><li><p><code>:xz</code>: Re-orient the noise space to have better visual isotropy in the XZ plane.</p></li><li><p><code>nothing</code>: Use the standard orientation.</p></li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mfiano/CoherentNoise.jl/blob/9a32e0f1afc48f2133fb7c58e1e734e493f30f86/src/noise_opensimplex2_3d.jl#L58-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoherentNoise.opensimplex2_4d-Tuple{}" href="#CoherentNoise.opensimplex2_4d-Tuple{}"><code>CoherentNoise.opensimplex2_4d</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">opensimplex2_4d(; kwargs...)</code></pre><p>Construct a sampler that outputs 4-dimensional OpenSimplex2 noise when it is sampled from.</p><p><strong>Arguments</strong></p><ul><li><p><code>seed=0</code>: An integer used to seed the random number generator for this sampler.</p></li><li><p><code>orient=nothing</code>: One of the following symbols or the value <code>nothing</code>:</p><ul><li><p><code>:x</code>: The noise space will be re-oriented with the Y axis pointing down the main diagonal to improve visual isotropy.</p></li><li><p><code>:xy</code>: Re-orient the noise space to have better visual isotropy in the XY plane.</p></li><li><p><code>:xz</code>: Re-orient the noise space to have better visual isotropy in the XZ plane.</p></li><li><p><code>:xyz</code>: Re-orient the noise space to be better suited for time-varied animations, where the W axis is time.</p></li><li><p><code>nothing</code>: Use the standard orientation.</p></li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mfiano/CoherentNoise.jl/blob/9a32e0f1afc48f2133fb7c58e1e734e493f30f86/src/noise_opensimplex2_4d.jl#L171-L193">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoherentNoise.opensimplex2s_2d-Tuple{}" href="#CoherentNoise.opensimplex2s_2d-Tuple{}"><code>CoherentNoise.opensimplex2s_2d</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">opensimplex2s_2d(; kwargs...)</code></pre><p>Construct a sampler that outputs 2-dimensional OpenSimplex2S noise when it is sampled from.</p><p><strong>Arguments</strong></p><ul><li><p><code>seed=0</code>: An integer used to seed the random number generator for this sampler.</p></li><li><p><code>orient=nothing</code>: Either the symbol <code>:x</code> or the value <code>nothing</code>:</p><ul><li><p><code>:x</code>: The noise space will be re-oriented with the Y axis pointing down the main diagonal to improve visual isotropy.</p></li><li><p><code>nothing</code>: Use the standard orientation.</p></li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mfiano/CoherentNoise.jl/blob/9a32e0f1afc48f2133fb7c58e1e734e493f30f86/src/noise_opensimplex2s_2d.jl#L4-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoherentNoise.opensimplex2s_3d-Tuple{}" href="#CoherentNoise.opensimplex2s_3d-Tuple{}"><code>CoherentNoise.opensimplex2s_3d</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">opensimplex2s_3d(; kwargs...)</code></pre><p>Construct a sampler that outputs 3-dimensional OpenSimplex2S noise when it is sampled from.</p><p><strong>Arguments</strong></p><ul><li><p><code>seed=0</code>: An integer used to seed the random number generator for this sampler.</p></li><li><p><code>orient=nothing</code>: One of the following symbols or the value <code>nothing</code>:</p><ul><li><p><code>:x</code>: The noise space will be re-oriented with the Y axis pointing down the main diagonal to improve visual isotropy.</p></li><li><p><code>:xy</code>: Re-orient the noise space to have better visual isotropy in the XY plane.</p></li><li><p><code>:xz</code>: Re-orient the noise space to have better visual isotropy in the XZ plane.</p></li><li><p><code>nothing</code>: Use the standard orientation.</p></li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mfiano/CoherentNoise.jl/blob/9a32e0f1afc48f2133fb7c58e1e734e493f30f86/src/noise_opensimplex2s_3d.jl#L4-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoherentNoise.opensimplex2s_4d-Tuple{}" href="#CoherentNoise.opensimplex2s_4d-Tuple{}"><code>CoherentNoise.opensimplex2s_4d</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">opensimplex2s_4d(; kwargs...)</code></pre><p>Construct a sampler that outputs 4-dimensional OpenSimplex2S noise when it is sampled from.</p><p><strong>Arguments</strong></p><ul><li><p><code>seed=0</code>: An integer used to seed the random number generator for this sampler.</p></li><li><p><code>orient=nothing</code>: One of the following symbols or the value <code>nothing</code>:</p><ul><li><p><code>:x</code>: The noise space will be re-oriented with the Y axis pointing down the main diagonal to improve visual isotropy.</p></li><li><p><code>:xy</code>: Re-orient the noise space to have better visual isotropy in the XY plane.</p></li><li><p><code>:xz</code>: Re-orient the noise space to have better visual isotropy in the XZ plane.</p></li><li><p><code>:xyz</code>: Re-orient the noise space to be better suited for time-varied animations, where the W axis is time.</p></li><li><p><code>nothing</code>: Use the standard orientation.</p></li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mfiano/CoherentNoise.jl/blob/9a32e0f1afc48f2133fb7c58e1e734e493f30f86/src/noise_opensimplex2s_4d.jl#L302-L324">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoherentNoise.opensimplex_2d-Tuple{}" href="#CoherentNoise.opensimplex_2d-Tuple{}"><code>CoherentNoise.opensimplex_2d</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">opensimplex_2d(; kwargs...)</code></pre><p>Construct a sampler that outputs 2-dimensional legacy OpenSimplex noise when it is sampled from.</p><p><strong>Arguments</strong></p><ul><li><code>seed=0</code>: An integer used to seed the random number generator for this sampler.</li></ul><p><strong>See also:</strong></p><ul><li><a href="#CoherentNoise.opensimplex2_2d-Tuple{}"><code>OpenSimplex2</code></a></li><li><a href="#CoherentNoise.opensimplex2s_2d-Tuple{}"><code>OpenSimplex2S</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mfiano/CoherentNoise.jl/blob/9a32e0f1afc48f2133fb7c58e1e734e493f30f86/src/noise_opensimplex_2d.jl#L6-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoherentNoise.opensimplex_3d-Tuple{}" href="#CoherentNoise.opensimplex_3d-Tuple{}"><code>CoherentNoise.opensimplex_3d</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">opensimplex_3d(; kwargs...)</code></pre><p>Construct a sampler that outputs 3-dimensional legacy OpenSimplex noise when it is sampled from.</p><p><strong>Arguments</strong></p><ul><li><code>seed=0</code>: An integer used to seed the random number generator for this sampler.</li></ul><p><strong>See also:</strong></p><ul><li><a href="#CoherentNoise.opensimplex2_3d-Tuple{}"><code>OpenSimplex2</code></a></li><li><a href="#CoherentNoise.opensimplex2s_3d-Tuple{}"><code>OpenSimplex2S</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mfiano/CoherentNoise.jl/blob/9a32e0f1afc48f2133fb7c58e1e734e493f30f86/src/noise_opensimplex_3d.jl#L11-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoherentNoise.opensimplex_4d-Tuple{}" href="#CoherentNoise.opensimplex_4d-Tuple{}"><code>CoherentNoise.opensimplex_4d</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">opensimplex_4d(; kwargs...)</code></pre><p>Construct a sampler that outputs 4-dimensional legacy OpenSimplex noise when it is sampled from.</p><p><strong>Arguments</strong></p><ul><li><code>seed=0</code>: An integer used to seed the random number generator for this sampler.</li></ul><p><strong>See also:</strong></p><ul><li><a href="#CoherentNoise.opensimplex2_4d-Tuple{}"><code>OpenSimplex2</code></a></li><li><a href="#CoherentNoise.opensimplex2s_4d-Tuple{}"><code>OpenSimplex2S</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mfiano/CoherentNoise.jl/blob/9a32e0f1afc48f2133fb7c58e1e734e493f30f86/src/noise_opensimplex_4d.jl#L16-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoherentNoise.perlin_improved_2d-Tuple{}" href="#CoherentNoise.perlin_improved_2d-Tuple{}"><code>CoherentNoise.perlin_improved_2d</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">perlin_improved_2d(; kwargs...)</code></pre><p>Construct a sampler that outputs 2-dimensional Perlin &quot;Improved&quot; noise when it is sampled from.</p><p><strong>Arguments</strong></p><ul><li><code>seed=0</code>: An integer used to seed the random number generator for this sampler.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mfiano/CoherentNoise.jl/blob/9a32e0f1afc48f2133fb7c58e1e734e493f30f86/src/noise_perlin_improved_2d.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoherentNoise.perlin_improved_3d-Tuple{}" href="#CoherentNoise.perlin_improved_3d-Tuple{}"><code>CoherentNoise.perlin_improved_3d</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">perlin_improved_3d(; kwargs...)</code></pre><p>Construct a sampler that outputs 3-dimensional Perlin &quot;Improved&quot; noise when it is sampled from.</p><p><strong>Arguments</strong></p><ul><li><code>seed=0</code>: An integer used to seed the random number generator for this sampler.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mfiano/CoherentNoise.jl/blob/9a32e0f1afc48f2133fb7c58e1e734e493f30f86/src/noise_perlin_improved_3d.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoherentNoise.perlin_improved_4d-Tuple{}" href="#CoherentNoise.perlin_improved_4d-Tuple{}"><code>CoherentNoise.perlin_improved_4d</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">perlin_improved_4d(; kwargs...)</code></pre><p>Construct a sampler that outputs 4-dimensional Perlin &quot;Improved&quot; noise when it is sampled from.</p><p><strong>Arguments</strong></p><ul><li><code>seed=0</code>: An integer used to seed the random number generator for this sampler.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mfiano/CoherentNoise.jl/blob/9a32e0f1afc48f2133fb7c58e1e734e493f30f86/src/noise_perlin_improved_4d.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoherentNoise.ridged_fractal_2d-Tuple{}" href="#CoherentNoise.ridged_fractal_2d-Tuple{}"><code>CoherentNoise.ridged_fractal_2d</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ridged_fractal_2d(; kwargs...)</code></pre><p>Construct a sampler that outputs a 2-dimensional ridged multifractal noise when it is sampled from.</p><p><strong>Arguments</strong></p><ul><li><p><code>seed=0</code>: An integer used to seed the random number generator for this sampler.</p></li><li><p><code>source::AbstractSampler=opensimplex2s_2d()</code>: A 2-dimensional sampler instance to use as the source of the fractal.</p></li><li><p><code>octaves=4</code>: An integer between 1 and 32, denoting the number of octaves to apply.</p></li><li><p><code>frequency=1.0</code>: The frequency of the first octave&#39;s signal.</p></li><li><p><code>lacunarity=2.0</code>: A multiplier that determines how quickly the frequency increases for successive octaves.</p></li><li><p><code>persistence=1.0</code>: A multiplier that determines how quickly the amplitude diminishes for successive octaves.</p></li><li><p><code>attenuation=2.0</code>: The attenuation to apply to the weight of each octave.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mfiano/CoherentNoise.jl/blob/9a32e0f1afc48f2133fb7c58e1e734e493f30f86/src/fractal_ridged.jl#L26-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoherentNoise.ridged_fractal_3d-Tuple{}" href="#CoherentNoise.ridged_fractal_3d-Tuple{}"><code>CoherentNoise.ridged_fractal_3d</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ridged_fractal_3d(; kwargs...)</code></pre><p>Construct a sampler that outputs a 3-dimensional ridged multifractal noise when it is sampled from.</p><p><strong>Arguments</strong></p><ul><li><p><code>seed=0</code>: An integer used to seed the random number generator for this sampler.</p></li><li><p><code>source::AbstractSampler=opensimplex2s_3d()</code>: A 3-dimensional sampler instance to use as the source of the fractal.</p></li><li><p><code>octaves=4</code>: An integer between 1 and 32, denoting the number of octaves to apply.</p></li><li><p><code>frequency=1.0</code>: The frequency of the first octave&#39;s signal.</p></li><li><p><code>lacunarity=2.0</code>: A multiplier that determines how quickly the frequency increases for successive octaves.</p></li><li><p><code>persistence=1.0</code>: A multiplier that determines how quickly the amplitude diminishes for successive octaves.</p></li><li><p><code>attenuation=2.0</code>: The attenuation to apply to the weight of each octave.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mfiano/CoherentNoise.jl/blob/9a32e0f1afc48f2133fb7c58e1e734e493f30f86/src/fractal_ridged.jl#L62-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoherentNoise.ridged_fractal_4d-Tuple{}" href="#CoherentNoise.ridged_fractal_4d-Tuple{}"><code>CoherentNoise.ridged_fractal_4d</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ridged_fractal_4d(; kwargs...)</code></pre><p>Construct a sampler that outputs a 4-dimensional ridged multifractal noise when it is sampled from.</p><p><strong>Arguments</strong></p><ul><li><p><code>seed=0</code>: An integer used to seed the random number generator for this sampler.</p></li><li><p><code>source::AbstractSampler=opensimplex2s_4d()</code>: A 4-dimensional sampler instance to use as the source of the fractal.</p></li><li><p><code>octaves=4</code>: An integer between 1 and 32, denoting the number of octaves to apply.</p></li><li><p><code>frequency=1.0</code>: The frequency of the first octave&#39;s signal.</p></li><li><p><code>lacunarity=2.0</code>: A multiplier that determines how quickly the frequency increases for successive octaves.</p></li><li><p><code>persistence=1.0</code>: A multiplier that determines how quickly the amplitude diminishes for successive octaves.</p></li><li><p><code>attenuation=2.0</code>: The attenuation to apply to the weight of each octave.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mfiano/CoherentNoise.jl/blob/9a32e0f1afc48f2133fb7c58e1e734e493f30f86/src/fractal_ridged.jl#L98-L121">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoherentNoise.rotate-Union{Tuple{S}, Tuple{N}} where {N, S&lt;:AbstractSampler{N}}" href="#CoherentNoise.rotate-Union{Tuple{S}, Tuple{N}} where {N, S&lt;:AbstractSampler{N}}"><code>CoherentNoise.rotate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rotate(source::AbstractSampler; x::Real=0.0, y::Real=0.0, z::Real=0.0)</code></pre><p>Construct a modifier sampler that rotates the input coordinates of sampler <code>source</code> around the origin before sampling from it.</p><p>The coordinate system is assumed to be left-handed.</p><p>The angle of rotation is specified in radians for the corresponding axis given by <code>x</code>, <code>y</code>, and <code>z</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mfiano/CoherentNoise.jl/blob/9a32e0f1afc48f2133fb7c58e1e734e493f30f86/src/mod_rotate.jl#L9-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoherentNoise.sample" href="#CoherentNoise.sample"><code>CoherentNoise.sample</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sample(sampler::AbstractSampler, x::Real)
sample(sampler::AbstractSampler, x::Real, y::Real)
sample(sampler::AbstractSampler, x::Real, y::Real, z::Real)
sample(sampler::AbstractSampler, x::Real, y::Real, z::Real, w::Real)</code></pre><p>Sample from <code>sampler</code> with the supplied coordinates. The number of coordinates should match the dimensionality of the sampler type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mfiano/CoherentNoise.jl/blob/9a32e0f1afc48f2133fb7c58e1e734e493f30f86/src/common.jl#L90-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoherentNoise.scale-Union{Tuple{S}, Tuple{N}, Tuple{S, Real}} where {N, S&lt;:AbstractSampler{N}}" href="#CoherentNoise.scale-Union{Tuple{S}, Tuple{N}, Tuple{S, Real}} where {N, S&lt;:AbstractSampler{N}}"><code>CoherentNoise.scale</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">scale(source::AbstractSampler, scale::Real=1.0)</code></pre><p>Construct a modifier sampler that uniformly scales the input coordinates of sampler <code>source</code> by the scalar <code>scale</code> before sampling from it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mfiano/CoherentNoise.jl/blob/9a32e0f1afc48f2133fb7c58e1e734e493f30f86/src/mod_scale.jl#L19-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoherentNoise.scale-Union{Tuple{S}, Tuple{N}} where {N, S&lt;:AbstractSampler{N}}" href="#CoherentNoise.scale-Union{Tuple{S}, Tuple{N}} where {N, S&lt;:AbstractSampler{N}}"><code>CoherentNoise.scale</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">scale(source::AbstractSampler; x::Real=1.0, y::Real=1.0, z::Real=1.0, w::Real=1.0)</code></pre><p>Construct a modifier sampler that scales the input coordinates of sampler <code>source</code> before sampling from it.</p><p>Each axis can be scaled independently with <code>x</code>, <code>y</code>, <code>z</code>, or <code>w</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mfiano/CoherentNoise.jl/blob/9a32e0f1afc48f2133fb7c58e1e734e493f30f86/src/mod_scale.jl#L7-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoherentNoise.select-Union{Tuple{C}, Tuple{S2}, Tuple{S1}, Tuple{N3}, Tuple{N2}, Tuple{N1}, Tuple{S1, S2, C}} where {N1, N2, N3, S1&lt;:AbstractSampler{N1}, S2&lt;:AbstractSampler{N2}, C&lt;:AbstractSampler{N3}}" href="#CoherentNoise.select-Union{Tuple{C}, Tuple{S2}, Tuple{S1}, Tuple{N3}, Tuple{N2}, Tuple{N1}, Tuple{S1, S2, C}} where {N1, N2, N3, S1&lt;:AbstractSampler{N1}, S2&lt;:AbstractSampler{N2}, C&lt;:AbstractSampler{N3}}"><code>CoherentNoise.select</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">select(x::AbstractSampler, y::AbstractSampler; kwargs...)</code></pre><p>Construct a modifier sampler that outputs either the out of sampler <code>x</code> or <code>y</code>, depending on the output of sampler <code>z</code>.</p><p>If the output of sampler <code>z</code> is within the range denoted by <code>min</code> and <code>max</code>, the output of sampler <code>y</code> is chosen. If the output of sampler <code>z</code> is outside of this range, the output of sampler <code>x</code> is chosen.</p><p><strong>Arguments</strong></p><ul><li><code>min::Real=-1.0</code>: A real number between -1.0 and 1.0 defining the lower bound of the selection range.</li><li><code>max::Real=1.0</code>: A real number between -1.0 and 1.0 defining the upper bound of the selection range.</li><li><code>falloff::Real=1.0</code>: A real number between 0.0 and 1.0 specifying the smoothness of the transition.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mfiano/CoherentNoise.jl/blob/9a32e0f1afc48f2133fb7c58e1e734e493f30f86/src/mod_select.jl#L11-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoherentNoise.simplex_2d-Tuple{}" href="#CoherentNoise.simplex_2d-Tuple{}"><code>CoherentNoise.simplex_2d</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">simplex_2d(; kwargs...)</code></pre><p>Construct a sampler that outputs 2-dimensional Perlin Simplex noise when it is sampled from.</p><p><strong>Arguments</strong></p><ul><li><code>seed=0</code>: An integer used to seed the random number generator for this sampler.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mfiano/CoherentNoise.jl/blob/9a32e0f1afc48f2133fb7c58e1e734e493f30f86/src/noise_simplex_2d.jl#L4-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoherentNoise.simplex_3d-Tuple{}" href="#CoherentNoise.simplex_3d-Tuple{}"><code>CoherentNoise.simplex_3d</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">simplex_3d(; kwargs...)</code></pre><p>Construct a sampler that outputs 3-dimensional Perlin Simplex noise when it is sampled from.</p><p><strong>Arguments</strong></p><ul><li><code>seed=0</code>: An integer used to seed the random number generator for this sampler.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mfiano/CoherentNoise.jl/blob/9a32e0f1afc48f2133fb7c58e1e734e493f30f86/src/noise_simplex_3d.jl#L4-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoherentNoise.simplex_4d-Tuple{}" href="#CoherentNoise.simplex_4d-Tuple{}"><code>CoherentNoise.simplex_4d</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">simplex_4d(; kwargs...)</code></pre><p>Construct a sampler that outputs 4-dimensional Perlin Simplex noise when it is sampled from.</p><p><strong>Arguments</strong></p><ul><li><code>seed=0</code>: An integer used to seed the random number generator for this sampler.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mfiano/CoherentNoise.jl/blob/9a32e0f1afc48f2133fb7c58e1e734e493f30f86/src/noise_simplex_4d.jl#L20-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoherentNoise.spheres_3d-Tuple{}" href="#CoherentNoise.spheres_3d-Tuple{}"><code>CoherentNoise.spheres_3d</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">spheres_3d(; kwargs...)</code></pre><p>Construct a sampler that outputs values that form a pattern representing concentric spheres when it is sampled from.</p><p><strong>Arguments</strong></p><ul><li><p><code>seed=0</code>: An integer used to seed the random number generator for this sampler.</p></li><li><p><code>frequency=1.0</code>: The frequency of the signal, which controls how small or large the spheres are.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mfiano/CoherentNoise.jl/blob/9a32e0f1afc48f2133fb7c58e1e734e493f30f86/src/pattern_spheres_3d.jl#L6-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoherentNoise.terrace-Union{Tuple{S}, Tuple{N}, Tuple{S, Vector{Float64}}} where {N, S&lt;:AbstractSampler{N}}" href="#CoherentNoise.terrace-Union{Tuple{S}, Tuple{N}, Tuple{S, Vector{Float64}}} where {N, S&lt;:AbstractSampler{N}}"><code>CoherentNoise.terrace</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">terrace(x::AbstractSampler, points::Vector{Pair{Float64,Float64}}; invert::Bool=false)</code></pre><p>Construct a modifier sampler that outputs the result of sampling from <code>x</code> after remapping its output to a terrace-forming curve.</p><p>The curve is defined by a <code>Vector</code> of <code>Float64</code>s given by <code>points</code>. Each point represents an input and output number.</p><p>When sampling from sampler <code>x</code>, the output is evaluated using the curve data, and maps it to a new output value.</p><p><strong>Arguments</strong></p><ul><li><code>invert::Bool=false</code>: Specify whether the curve is inverted between control points.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mfiano/CoherentNoise.jl/blob/9a32e0f1afc48f2133fb7c58e1e734e493f30f86/src/mod_terrace.jl#L8-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoherentNoise.translate-Union{Tuple{S}, Tuple{N}} where {N, S&lt;:AbstractSampler{N}}" href="#CoherentNoise.translate-Union{Tuple{S}, Tuple{N}} where {N, S&lt;:AbstractSampler{N}}"><code>CoherentNoise.translate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">translate(source::AbstractSampler; x::Real=0.0, y::Real=0.0, z::Real=0.0, w::Real=0.0)</code></pre><p>Construct a modifier sampler that translates the input coordinates of sampler <code>source</code> along a specified vector, with a direction and magnitude given by the coordinates <code>x</code>, <code>y</code>, <code>z</code>, and <code>w</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mfiano/CoherentNoise.jl/blob/9a32e0f1afc48f2133fb7c58e1e734e493f30f86/src/mod_translate.jl#L7-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoherentNoise.turbulence-Union{Tuple{S2}, Tuple{S1}, Tuple{N1}, Tuple{N}, Tuple{S1, S2}} where {N, N1, S1&lt;:AbstractSampler{N}, S2&lt;:AbstractSampler{N1}}" href="#CoherentNoise.turbulence-Union{Tuple{S2}, Tuple{S1}, Tuple{N1}, Tuple{N}, Tuple{S1, S2}} where {N, N1, S1&lt;:AbstractSampler{N}, S2&lt;:AbstractSampler{N1}}"><code>CoherentNoise.turbulence</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">turbulence(s1::AbstractSampler; s2::AbstractSampler; kwargs...)</code></pre><p>Construct a modifier sampler that displaces the input coordinates of sampler <code>s1</code> by the output of sampler <code>s2</code> with a fractional Brownian motion fractal applied to it.</p><p>Sampler <code>s2</code>&#39;s input coordinates are randomly generated using the seed of sampler <code>s1</code>.</p><p><strong>Arguments</strong></p><ul><li><code>frequency::Real=1.0</code>: The frequency of the fractal signal to apply to sampler <code>s2</code>.</li><li><code>roughness::Real=3</code>: The number of octaves of the fractal to apply to sampler <code>s2</code>.</li><li><code>power::Real=1.0</code>: A scaling factor that is applied to the displaced result before sampling from sampler <code>s1</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mfiano/CoherentNoise.jl/blob/9a32e0f1afc48f2133fb7c58e1e734e493f30f86/src/mod_turbulence.jl#L12-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoherentNoise.value_2d-Tuple{}" href="#CoherentNoise.value_2d-Tuple{}"><code>CoherentNoise.value_2d</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">value_2d(; kwargs...)</code></pre><p>Construct a sampler that outputs 2-dimensonal value noise when it is sampled from.</p><p><strong>Arguments</strong></p><ul><li><code>seed=0</code>: An integer used to seed the random number generator for this sampler.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mfiano/CoherentNoise.jl/blob/9a32e0f1afc48f2133fb7c58e1e734e493f30f86/src/noise_value_2d.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoherentNoise.value_3d-Tuple{}" href="#CoherentNoise.value_3d-Tuple{}"><code>CoherentNoise.value_3d</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">value_3d(; kwargs...)</code></pre><p>Construct a sampler that outputs 3-dimensonal value noise when it is sampled from.</p><p><strong>Arguments</strong></p><ul><li><code>seed=0</code>: An integer used to seed the random number generator for this sampler.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mfiano/CoherentNoise.jl/blob/9a32e0f1afc48f2133fb7c58e1e734e493f30f86/src/noise_value_3d.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoherentNoise.value_4d-Tuple{}" href="#CoherentNoise.value_4d-Tuple{}"><code>CoherentNoise.value_4d</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">value_4d(; kwargs...)</code></pre><p>Construct a sampler that outputs 4-dimensonal value noise when it is sampled from.</p><p><strong>Arguments</strong></p><ul><li><code>seed=0</code>: An integer used to seed the random number generator for this sampler.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mfiano/CoherentNoise.jl/blob/9a32e0f1afc48f2133fb7c58e1e734e493f30f86/src/noise_value_4d.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoherentNoise.warp-Union{Tuple{SW}, Tuple{SZ}, Tuple{SY}, Tuple{SX}, Tuple{S}, Tuple{N4}, Tuple{N3}, Tuple{N2}, Tuple{N1}, Tuple{N}} where {N, N1, N2, N3, N4, S&lt;:AbstractSampler{N}, SX&lt;:AbstractSampler{N1}, SY&lt;:AbstractSampler{N2}, SZ&lt;:AbstractSampler{N3}, SW&lt;:AbstractSampler{N4}}" href="#CoherentNoise.warp-Union{Tuple{SW}, Tuple{SZ}, Tuple{SY}, Tuple{SX}, Tuple{S}, Tuple{N4}, Tuple{N3}, Tuple{N2}, Tuple{N1}, Tuple{N}} where {N, N1, N2, N3, N4, S&lt;:AbstractSampler{N}, SX&lt;:AbstractSampler{N1}, SY&lt;:AbstractSampler{N2}, SZ&lt;:AbstractSampler{N3}, SW&lt;:AbstractSampler{N4}}"><code>CoherentNoise.warp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">warp(source::AbstractSampler; kwargs...)</code></pre><p>Construct a modifier sampler that performs domain warping of the sampler <code>source</code> before sampling from it.</p><p>Domain warping feeds the output of other samplers to the input of a sampler. For this modifier, each input coordinate can specify a different sampler to warp with.</p><p>If a sampler is not supplied for <code>x</code>, <code>y</code>, <code>z</code>, or <code>w</code>, a sampler that outputs a constant zero will be used instead.</p><p><strong>Arguments</strong></p><ul><li><code>x::AbstractSampler=constant_1d()</code>: A sampler to warp the X axis by.</li><li><code>y::AbstractSampler=constant_1d()</code>: A sampler to warp the Y axis by.</li><li><code>z::AbstractSampler=constant_1d()</code>: A sampler to warp the Z axis by.</li><li><code>w::AbstractSampler=constant_1d()</code>: A sampler to warp the W axis by.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mfiano/CoherentNoise.jl/blob/9a32e0f1afc48f2133fb7c58e1e734e493f30f86/src/mod_warp.jl#L7-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoherentNoise.worley_2d-Tuple{}" href="#CoherentNoise.worley_2d-Tuple{}"><code>CoherentNoise.worley_2d</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">worley_2d(; kwargs...)</code></pre><p>Construct a sampler that outputs 2-dimensional Worley noise when it is sampled from.</p><p><strong>Arguments</strong></p><ul><li><p><code>seed=0</code>: An integer used to seed the random number generator for this sampler.</p></li><li><p><code>jitter=1.0</code>: A <code>Real</code> number between 0.0 and 1.0, with values closer to one randomly distributing cells away from their grid alignment.</p></li><li><p><code>metric=:euclidean</code>: One of the following symbols:</p><ul><li><p><code>:manhattan</code>: Use the Manhattan distance to the next cell (Minkowski metric <span>$p = 2^0$</span>).</p></li><li><p><code>:euclidean</code>: Use the Euclidean distance to the next cell (Minkowski metric <span>$p = 2^1$</span>).</p></li><li><p><code>:euclidean²</code>: Same as <code>:euclidean</code> but slighter faster due to no <span>$\sqrt{}$</span>.</p></li><li><p><code>:minkowski4</code>: Use Minkowski metric with <span>$p = 2^4$</span> for the distance to the next cell.</p></li><li><p><code>:chebyshev</code>: Use the Chebyshev distance to the next cell (Minkowski metric <span>$p = 2^\infty$</span>).</p></li></ul></li><li><p><code>output=:f1</code>: One of the following symbols:</p><ul><li><p><code>:f1</code>: Calculate the distance to the nearest cell as the output.</p></li><li><p><code>:f2</code>: Calculate the distance to the second-nearest cell as the output.</p></li><li><p><code>:+</code>: Calculate <code>:f1</code> + <code>:f2</code> as the output.</p></li><li><p><code>:-</code>: Calculate <code>:f2</code> - <code>:f1</code> as the output.</p></li><li><p><code>:*</code>: Calculate <code>:f1</code> * <code>:f2</code> as the output.</p></li><li><p><code>:/</code>: Calculate <code>:f1</code> / <code>:f2</code> as the output.</p></li><li><p><code>:value</code>: Use the cell&#39;s hash value as the output.</p></li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mfiano/CoherentNoise.jl/blob/9a32e0f1afc48f2133fb7c58e1e734e493f30f86/src/noise_worley_2d.jl#L1-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoherentNoise.worley_3d-Tuple{}" href="#CoherentNoise.worley_3d-Tuple{}"><code>CoherentNoise.worley_3d</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">worley_3d(; kwargs...)</code></pre><p>Construct a sampler that outputs 3-dimensional Worley noise when it is sampled from.</p><p><strong>Arguments</strong></p><ul><li><p><code>seed=0</code>: An integer used to seed the random number generator for this sampler.</p></li><li><p><code>jitter=1.0</code>: A <code>Real</code> number between 0.0 and 1.0, with values closer to one randomly distributing cells away from their grid alignment.</p></li><li><p><code>metric=:euclidean</code>: One of the following symbols:</p><ul><li><p><code>:manhattan</code>: Use the Manhattan distance to the next cell (Minkowski metric <span>$p = 2^0$</span>).</p></li><li><p><code>:euclidean</code>: Use the Euclidean distance to the next cell (Minkowski metric <span>$p = 2^1$</span>).</p></li><li><p><code>:euclidean²</code>: Same as <code>:euclidean</code> but slighter faster due to no <span>$\sqrt{}$</span>.</p></li><li><p><code>:minkowski4</code>: Use Minkowski metric with <span>$p = 2^4$</span> for the distance to the next cell.</p></li><li><p><code>:chebyshev</code>: Use the Chebyshev distance to the next cell (Minkowski metric <span>$p = 2^\infty$</span>).</p></li></ul></li><li><p><code>output=:f1</code>: One of the following symbols:</p><ul><li><p><code>:f1</code>: Calculate the distance to the nearest cell as the output.</p></li><li><p><code>:f2</code>: Calculate the distance to the second-nearest cell as the output.</p></li><li><p><code>:+</code>: Calculate <code>:f1</code> + <code>:f2</code> as the output.</p></li><li><p><code>:-</code>: Calculate <code>:f2</code> - <code>:f1</code> as the output.</p></li><li><p><code>:*</code>: Calculate <code>:f1</code> * <code>:f2</code> as the output.</p></li><li><p><code>:/</code>: Calculate <code>:f1</code> / <code>:f2</code> as the output.</p></li><li><p><code>:value</code>: Use the cell&#39;s hash value as the output.</p></li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mfiano/CoherentNoise.jl/blob/9a32e0f1afc48f2133fb7c58e1e734e493f30f86/src/noise_worley_3d.jl#L1-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoherentNoise.worley_4d-Tuple{}" href="#CoherentNoise.worley_4d-Tuple{}"><code>CoherentNoise.worley_4d</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">worley_4d(; kwargs...)</code></pre><p>Construct a sampler that outputs 4-dimensional Worley noise when it is sampled from.</p><p><strong>Arguments</strong></p><ul><li><p><code>seed=0</code>: An integer used to seed the random number generator for this sampler.</p></li><li><p><code>jitter=1.0</code>: A <code>Real</code> number between 0.0 and 1.0, with values closer to one randomly distributing cells away from their grid alignment.</p></li><li><p><code>metric=:euclidean</code>: One of the following symbols:</p><ul><li><p><code>:manhattan</code>: Use the Manhattan distance to the next cell (Minkowski metric <span>$p = 2^0$</span>).</p></li><li><p><code>:euclidean</code>: Use the Euclidean distance to the next cell (Minkowski metric <span>$p = 2^1$</span>).</p></li><li><p><code>:euclidean²</code>: Same as <code>:euclidean</code> but slighter faster due to no <span>$\sqrt{}$</span>.</p></li><li><p><code>:minkowski4</code>: Use Minkowski metric with <span>$p = 2^4$</span> for the distance to the next cell.</p></li><li><p><code>:chebyshev</code>: Use the Chebyshev distance to the next cell (Minkowski metric <span>$p = 2^\infty$</span>).</p></li></ul></li><li><p><code>output=:f1</code>: One of the following symbols:</p><ul><li><p><code>:f1</code>: Calculate the distance to the nearest cell as the output.</p></li><li><p><code>:f2</code>: Calculate the distance to the second-nearest cell as the output.</p></li><li><p><code>:+</code>: Calculate <code>:f1</code> + <code>:f2</code> as the output.</p></li><li><p><code>:-</code>: Calculate <code>:f2</code> - <code>:f1</code> as the output.</p></li><li><p><code>:*</code>: Calculate <code>:f1</code> * <code>:f2</code> as the output.</p></li><li><p><code>:/</code>: Calculate <code>:f1</code> / <code>:f2</code> as the output.</p></li><li><p><code>:value</code>: Use the cell&#39;s hash value as the output.</p></li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mfiano/CoherentNoise.jl/blob/9a32e0f1afc48f2133fb7c58e1e734e493f30f86/src/noise_worley_4d.jl#L1-L41">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../gallery/">« Gallery</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.22 on <span class="colophon-date" title="Saturday 20 August 2022 07:32">Saturday 20 August 2022</span>. Using Julia version 1.8.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
