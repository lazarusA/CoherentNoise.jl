import{_ as e,c as i,o as a,a7 as o}from"./chunks/framework.BZT1wHXU.js";const f=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"overview.md","filePath":"overview.md","lastUpdated":null}'),t={name:"overview.md"},r=o('<h2 id="What-is-coherent-noise?" tabindex="-1">What is coherent noise? <a class="header-anchor" href="#What-is-coherent-noise?" aria-label="Permalink to &quot;What is coherent noise? {#What-is-coherent-noise?}&quot;">​</a></h2><p>Unlike its more random cousin, coherent noise has interesting properties that give it a smooth appearance. A coherent noise function is a function that emits a single scalar value as its output. All coherent noise functions exhibit the following three properties:</p><ol><li><p>The same input arguments will always result in the same output.</p></li><li><p>A small change in input will result in a small change in the output.</p></li><li><p>A large change in input will result in a random output.</p></li></ol><p>The dimensionality of a coherent noise function is determined by how many input arguments it accepts. Since inputs to a coherent noise function could be driven from any source of data, and output values are spatially coherent in each dimension, one could feed image coordinates into a 3-dimensional coherent noise function&#39;s first two arguments, and an incrementing time value as the third argument, in order to smoothly animate an image effect such as clouds, fire, landscapes, or anything else creativity dreams up. Similarly, one could render a 3-dimensional volume, and animate it along a 4th dimension.</p><p>Coherent noise functions are especially ubiquitous in applications where memory is scarce, and in game development where one wants to generate 2-dimensional textures or 3-dimensional objects without storing large chunks of image or geometry data on disk.</p><h2 id="history" tabindex="-1">History <a class="header-anchor" href="#history" aria-label="Permalink to &quot;History&quot;">​</a></h2><p>CoherentNoise started out as a <a href="https://git.mfiano.net/mfiano/cricket" target="_blank" rel="noreferrer">Common Lisp library</a> providing a collection of noise algorithms for use in game development, but evolved over time into a more general form we thought could be useful to others outside of that domain. Additionally, the author has since migrated from Common Lisp to Julia, and here this port with even more functionality was born. The implementation borrows a lot of its ideas from <a href="http://libnoise.sourceforge.net/" target="_blank" rel="noreferrer">C++&#39;s libnoise</a> and other noise libraries, but adds numerous enhancements, corrections, and additional noise algorithms.</p><p>As mentioned, the main author, Michael Fiano, has recently moved to Julia after nearly 20 years of exclusive Common Lisp development. CoherentNoise is a realization of their first Julia library, and as such, code may not be the most idiomatic in nature. However, it was a goal to produce something as Julian as possible, and with a focus on performance and precision, than to directly port the original Common Lisp implementation. If something can be improved in this regard, please open an issue or pull request – it would be wonderful if I could stengthen my Julia knowledge by discussion or contribution by more experienced Julia developers that find value in CoherentNoise.</p><h2 id="What&#39;s-different-from-other-libraries?" tabindex="-1">What&#39;s different from other libraries? <a class="header-anchor" href="#What&#39;s-different-from-other-libraries?" aria-label="Permalink to &quot;What&amp;#39;s different from other libraries? {#What&#39;s-different-from-other-libraries?}&quot;">​</a></h2><ul><li><p>Many more noise algorithms than libnoise supported, and well-tested.</p></li><li><p>Algorithms are consistently implemented in multiple dimensions, whereas libnoise only has 3-dimensional gradient noise.</p></li><li><p>Some terminology corrections. For example, libnoise refers to multiple octaves of gradient noise as &quot;Perlin&quot; noise. Perlin is an implementation of gradient noise, and is not defined in terms of a fractal; infact, any noise algorithm can be &quot;fractalized&quot;.</p></li><li><p>Fix quite a few fundamental mathematical errors. It was quite the task re-implementing some algorithms due to incorrect math, or the inclusion of magic numbers that differed among implementations for various reasons.</p></li><li><p>Ensure that all samplers emit values in the [-1.0, 1.0] range; something that becomes very important when working with fractal-based noises, composition of complex noises, and in general is something just expected when working with coherent noise.</p></li><li><p>The Perlin noise implementation is <a href="https://cs.nyu.edu/~perlin/noise/" target="_blank" rel="noreferrer">Ken Perlin&#39;s &quot;Improved Noise&quot; algorithm</a>, unlike his classic Perlin noise algorithm found in libnoise, which is sometimes just called gradient noise.</p></li><li><p>Fractal samplers can be driven by any source sampler, not just gradient noise – even other fractal samplers.</p></li><li><p>Additional modifier samplers.</p></li><li><p>Traditional Simplex noise variants, even the original Simplex by Ken Perlin, all overshoot the radial extent used for the signal reconstruction kernel. This results in unwanted artifacts when the noise is used for certain applications. CoherentNoise adds an option to use a more correct kernel to remove these artifacts. This is disabled by default. See the documentation for the respective Simplex noise variant for more details. To the best of my knowledge, CoherentNoise is the only library that offers this option for all Simplex noise variants.</p></li></ul><h3 id="How-is-it-used?" tabindex="-1">How is it used? <a class="header-anchor" href="#How-is-it-used?" aria-label="Permalink to &quot;How is it used? {#How-is-it-used?}&quot;">​</a></h3><p>In summary, you call a function corresponding to the coherent noise algorithm and dimensionality you want to generate, in order to create a &quot;sampler&quot;. A sampler can then be sampled from with the <code>sample</code> function, by passing to it a sampler instance, along with input coordinates for each of the sampler&#39;s dimensions.</p><p>In addition to noise algorithm samplers, there are simple pattern samplers, and higher-order fractal and modifier samplers.</p><p>Pattern samplers create simple patterns, like checkerboards, and are useful in noise composition pipelines.</p><p>Higher-order samplers include both fractal samplers and modifier samplers.</p><p>Fractal sampler functions accept another sampler as an input source, and produce much more interesting results by combining the results of multiple octaves of the source.</p><p>Modifier sampler functions also accept other sampler instances as input; and modify their input coordinates or output values in interesting ways. Modifiers are the crux of CoherentNoise&#39;s composition pipeline support, and allow merging different samplers together, even other modifiers, into a composition of potentially very complex and interesting results.</p><p>Finally, there are tools available to conveniently work with 2-dimensional slices of multi-dimensional noise spaces in order to generate entire images effortlessly.</p><h2 id="Available-samplers" tabindex="-1">Available samplers <a class="header-anchor" href="#Available-samplers" aria-label="Permalink to &quot;Available samplers {#Available-samplers}&quot;">​</a></h2><p>The following noise algorithms and other samplers are implemented. If you would like to see support for other algorithms, please file an issue or submit a pull request.</p><h3 id="Noise-samplers" tabindex="-1">Noise samplers <a class="header-anchor" href="#Noise-samplers" aria-label="Permalink to &quot;Noise samplers {#Noise-samplers}&quot;">​</a></h3><p>In the order of &quot;recommended to try first&quot;:</p><ul><li><p>OpenSimplex2: (2D, 3D, 4D)</p></li><li><p>Simplex: (1D, 2D, 3D, 4D)</p></li><li><p>OpenSimplex2S: (2D, 3D, 4D)</p></li><li><p>OpenSimplex: (2D, 3D, 4D)</p></li><li><p>Perlin: (1D, 2D, 3D, 4D)</p></li><li><p>Value cubic: (1D, 2D, 3D, 4D)</p></li><li><p>Value: (1D, 2D, 3D, 4D)</p></li><li><p>Worley: (1D, 2D, 3D, 4D)</p></li></ul><h3 id="Pattern-samplers" tabindex="-1">Pattern samplers <a class="header-anchor" href="#Pattern-samplers" aria-label="Permalink to &quot;Pattern samplers {#Pattern-samplers}&quot;">​</a></h3><ul><li><p>Constant: (1D)</p></li><li><p>Checkered: (2D)</p></li><li><p>Cylinders: (2D)</p></li><li><p>Spheres: (3D)</p></li></ul><h3 id="Fractal-samplers" tabindex="-1">Fractal samplers <a class="header-anchor" href="#Fractal-samplers" aria-label="Permalink to &quot;Fractal samplers {#Fractal-samplers}&quot;">​</a></h3><ul><li><p>fBm: (fractional Brownian motion; 1D, 2D, 3D, 4D)</p></li><li><p>Billow: (1D, 2D, 3D, 4D)</p></li><li><p>Multifractal: (1D, 2D, 3D, 4D)</p></li><li><p>Hybrid: (1D, 2D, 3D, 4D)</p></li><li><p>Ridged: (1D, 2D, 3D, 4D)</p></li></ul><h3 id="Modifier-samplers" tabindex="-1">Modifier samplers <a class="header-anchor" href="#Modifier-samplers" aria-label="Permalink to &quot;Modifier samplers {#Modifier-samplers}&quot;">​</a></h3><ul><li><p><code>+</code>: binary addition of two samplers</p></li><li><p><code>+</code>: binary addition of a sampler and a scalar</p></li><li><p><code>-</code>: binary subtraction of two samplers</p></li><li><p><code>-</code>: binary subtraction of a sampler and a scalar</p></li><li><p><code>-</code>: unary subtraction of a sampler</p></li><li><p><code>*</code>: binary multiplication of two samplers</p></li><li><p><code>*</code>: binary multiplication of a sampler and a scalar</p></li><li><p><code>/</code>: binary division of two samplers</p></li><li><p><code>/</code>: binary division of a sampler and a scalar</p></li><li><p><code>^</code>: binary exponentiation of two samplers</p></li><li><p><code>abs</code>: absolute value of a sampler</p></li><li><p><code>cache</code>: cache the last output of a sampler</p></li><li><p><code>clamp</code>: restrict the range of a sampler by the bounds specified by the output of two other samplers</p></li><li><p><code>clamp</code>: restrict the range of a sampler by the bounds specified by two scalars</p></li><li><p><code>copysign</code>: change the sign of a sampler to that of the output of another sampler</p></li><li><p><code>curve</code>: maps the output of a sampler onto an arbitrary user-defined curve</p></li><li><p><code>max</code>: take the maximum value of two samplers</p></li><li><p><code>min</code>: take the minimum value of two samplers</p></li><li><p><code>mix</code>: linearly interpolate the result of two samplers by the result of a third alpha sampler</p></li><li><p><code>mix</code>: linearly interpolate the result of two samplers by a scalar</p></li><li><p><code>muladd</code>: multiplication followed by addition of a sampler by two scalars</p></li><li><p><code>rotate</code>: rotate the noise space of a sampler around its origin by scalars denoting axis angles of rotation in radians</p></li><li><p><code>scale</code>: scale the input coordinates of a sampler by scalars for the specified axes</p></li><li><p><code>scale</code>: uniformly scale the input coordinates of a sampler along all axes</p></li><li><p><code>select</code>: select the result of one of two samplers decided upon by the output of a third sampler</p></li><li><p><code>terrace</code>: map the output of a sampler onto a terrace-forming curve</p></li><li><p><code>translate</code>: translate (move) the noise space of a sampler along the specified axes</p></li><li><p><code>turbulence</code>: randomly displace the input coordinates of a sampler before sampling from it</p></li><li><p><code>warp</code>: domain-warps the sampler by modifying its input coordinates to be summed with the result of another supplied sampler for each coordinate</p></li></ul>',29),s=[r];function l(n,p,d,c,m,h){return a(),i("div",null,s)}const b=e(t,[["render",l]]);export{f as __pageData,b as default};
